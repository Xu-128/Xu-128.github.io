<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022-03-09 模拟赛题解</title>
    <link href="/2022/03/09/2022-03-09-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/09/2022-03-09-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-03-09-模拟赛题解"><a href="#2022-03-09-模拟赛题解" class="headerlink" title="2022-03-09 模拟赛题解"></a>2022-03-09 模拟赛题解</h1><h2 id="T1-AGC034D"><a href="#T1-AGC034D" class="headerlink" title="T1 (AGC034D)"></a>T1 (AGC034D)</h2><p>看一眼题面，再看一眼数据范围，网络瘤！但是直接暴力连边数量是 $O(n^2)$ 的，虽然网络流的时间复杂度比较玄学，但是跑 $1e6$ 条边还是有点困难，所以考虑优化连边。</p><p>我们考虑一下曼哈顿距离的定义式</p><script type="math/tex; mode=display">Dis(i, j)=|x_i-x_j|+|y_i-y_j|</script><p>由于有绝对值符号不好计算，所以直接分情况暴力展开</p><script type="math/tex; mode=display">Dis(i, j)=\begin{cases}(x_i-x_j)+(y_i-y_j)=(x_i+y_i)+(-x_j-y_j)\\(x_i-x_j)+(-y_i+y_j)=(x_i-y_i)+(-x_j+y_j)\\(-x_i+x_j)+(y_i-y_j)=(-x_i+y_i)+(x_j-y_j)\\(-x_i+x_j)+(-y_i+y_j)=(-x_i-y_i)+(x_j+y_j)\\\end{cases}</script><p>考虑额外新建 $4$ 个点，分别表示四种情况。从源点向黑点连边，每一个黑点再向额外的新建点按照上述讨论连边。</p><p>但是这样还有一个问题，因为可能会出现最大流流错位的情况，仔细考虑一下就会发现这样是不会出现这种情况的，原因是根据绝对值的性质，如果整体取了负号结果一定会变小，又因为费用流的性质所以能够保证满足题目性质。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">6e6</span> + <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-type">int</span> N;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NET</span> &#123;<br><span class="hljs-type">int</span> size, s, t;<br><span class="hljs-type">int</span> tot, head[kN], next[kN], ver[kN], edge[kN], money[kN];<br><span class="hljs-type">int</span> dis[kN], vis[kN], now[kN], use;<br><span class="hljs-built_in">NET</span>() &#123; tot = <span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>ver[++tot] = y, next[tot] = head[x], head[x] = tot, edge[tot] = z, money[tot] = w;<br>ver[++tot] = x, next[tot] = head[y], head[y] = tot, edge[tot] = <span class="hljs-number">0</span>, money[tot] = -w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span> </span>&#123;<br>queue &lt; <span class="hljs-type">int</span> &gt; Q;<br><span class="hljs-built_in">FL</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">int</span>) * (size + <span class="hljs-number">5</span>)), <span class="hljs-built_in">FL</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">int</span>)  * (size + <span class="hljs-number">5</span>));<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tmp</span><span class="hljs-params">(dis[<span class="hljs-number">0</span>])</span></span>;<br>Q.<span class="hljs-built_in">push</span>(s), dis[s] = <span class="hljs-number">0</span>, vis[s] = <span class="hljs-number">1</span>, now[s] = head[s];<br><span class="hljs-comment">//TE();</span><br><span class="hljs-keyword">while</span> (Q.<span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(Q.front())</span></span>; Q.<span class="hljs-built_in">pop</span>(), vis[x] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">ER</span>(e, x, y) &#123;<br><span class="hljs-keyword">if</span> (edge[e] <span class="hljs-keyword">and</span> dis[y] &gt; dis[x] + money[e]) &#123;<br>dis[y] = dis[x] + money[e], now[y] = head[y];<br><span class="hljs-keyword">if</span> (!vis[y]) &#123;<br>vis[y] = <span class="hljs-number">1</span>;<br>Q.<span class="hljs-built_in">push</span>(y);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//TE();</span><br><span class="hljs-built_in">FL</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) * (size + <span class="hljs-number">5</span>)); <span class="hljs-keyword">return</span> dis[t] != tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">Dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> flow)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == t) <span class="hljs-keyword">return</span> flow;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rest</span><span class="hljs-params">(flow)</span></span>;<br>vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;<span class="hljs-built_in">e</span>(now[x]); e; e = next[e]) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">y</span><span class="hljs-params">(ver[e])</span></span>;<br><span class="hljs-keyword">if</span> (edge[e] <span class="hljs-keyword">and</span> dis[y] == dis[x] + money[e] <span class="hljs-keyword">and</span> !vis[y]) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">k</span><span class="hljs-params">(Dinic(y, min(rest, edge[e])))</span></span>;<br>rest -= k, edge[e] -= k, edge[e ^ <span class="hljs-number">1</span>] += k, use += k * money[e];<br><span class="hljs-keyword">if</span> (!k) dis[y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!rest) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>vis[x] = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> flow - rest;<br>&#125;<br>&#125; Gp;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N;<br>Gp.size = (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">6</span>;<br>Gp.s = (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">5</span>, Gp.t = (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">6</span>;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N, x, y, c)  &#123;<br>IN &gt;&gt; x &gt;&gt; y &gt;&gt; c;<br>Gp.<span class="hljs-built_in">Ins</span>(Gp.s, i, c, <span class="hljs-number">0</span>);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, INF, x + y);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>, INF, x - y);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">3</span>, INF, -x + y);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>, INF, -x - y);<br>&#125;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N, x, y, c)  &#123;<br>IN &gt;&gt; x &gt;&gt; y &gt;&gt; c;<br>Gp.<span class="hljs-built_in">Ins</span>(i + N, Gp.t, c, <span class="hljs-number">0</span>);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, i + N, INF, -x - y);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>, i + N, INF, -x + y);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">3</span>, i + N, INF, x - y);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>, i + N, INF, x + y);<br>&#125;<br><span class="hljs-keyword">while</span> (Gp.<span class="hljs-built_in">SPFA</span>()) Gp.<span class="hljs-built_in">Dinic</span>(Gp.s, INF);<br>cout &lt;&lt; -Gp.use &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2-ARC073C"><a href="#T2-ARC073C" class="headerlink" title="T2 (ARC073C)"></a>T2 (ARC073C)</h2><p>下面对于每一组的两个球 $x,~y$，默认 $x&lt;y$。</p><p>如果我们已经有了一种最优方案，那么将这种方案的红黑互换对于答案是没有影响的。</p><p>所以我们可以钦定最大值被染成红色，然后分情况讨论。</p><p>第一种情况，最小值是黑色。这种情况下我们就贪心地将 $x$ 都给黑色，$y$ 都给红色。</p><p>第二种情况，最小值是红色。这时红球的答案已经知道了，把二元组按照 $x$ 从小到大排序，然后钦定 $[2,n]$ 里的某一个 $x$ 为黑色的最小值，然后这个二元组之后的都选 $x$（因为 $x<y$，而我们要尽量让最大值和最小值的差值小，所以要尽可能选择小的数），之前的都选 $y$（因为之前选了 $x$ 那当前这个就不是最小值了），此时黑色的答案就是<b> $min$（这之前 $y$ 的最小值，x） - $max$（这之前 $y$ 的最大值，最后的 $x$）&lt;/b&gt;，和红色的乘起来就做完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair <span class="hljs-string">&lt; int, int &gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for (int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0ull</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-type">int</span> N, Ans;<br>PII A[kN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Bmax</span><span class="hljs-params">(-INF)</span>, <span class="hljs-title">Bmin</span><span class="hljs-params">(INF)</span>, <span class="hljs-title">Rmax</span><span class="hljs-params">(-INF)</span>, <span class="hljs-title">Rmin</span><span class="hljs-params">(INF)</span></span>;<br><span class="hljs-type">int</span> PreMAX[kN], PreMIN[kN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Cmp</span><span class="hljs-params">(PII A, PII B)</span> </span>&#123;<br><span class="hljs-keyword">return</span> A.first &lt; B.first;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N, x, y) &#123;<br>IN &gt;&gt; x &gt;&gt; y; <span class="hljs-keyword">if</span> (x &gt; y) <span class="hljs-built_in">swap</span>(x, y);<br>Bmax = <span class="hljs-built_in">max</span>(Bmax, x), Bmin = <span class="hljs-built_in">min</span>(Bmin, x);<br>Rmax = <span class="hljs-built_in">max</span>(Rmax, y), Rmin = <span class="hljs-built_in">min</span>(Rmin, y); A[i] = &#123;x, y&#125;;<br>&#125;<br>Ans = (Bmax - Bmin) * (Rmax - Rmin); PreMAX[<span class="hljs-number">0</span>] = -INF, PreMIN[<span class="hljs-number">0</span>] = INF;<br><span class="hljs-built_in">sort</span>(A + <span class="hljs-number">1</span>, A + <span class="hljs-number">1</span> + N, Cmp); Rmin = A[<span class="hljs-number">1</span>].first;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) PreMAX[i] = <span class="hljs-built_in">max</span>(PreMAX[i - <span class="hljs-number">1</span>], A[i].second), PreMIN[i] = <span class="hljs-built_in">min</span>(PreMIN[i - <span class="hljs-number">1</span>], A[i].second);<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">2</span>, N) &#123;<br>Ans = <span class="hljs-built_in">min</span>(Ans, (Rmax - Rmin) * (<span class="hljs-built_in">max</span>(PreMAX[i - <span class="hljs-number">1</span>], A[N].first) - <span class="hljs-built_in">min</span>(PreMIN[i - <span class="hljs-number">1</span>], A[i].first)));<br>&#125;<br>cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3-AGC028D"><a href="#T3-AGC028D" class="headerlink" title="T3 (AGC028D)"></a>T3 (AGC028D)</h2><p>直接考虑区间 DP。</p><p>设 $n=2N$。<br>考虑 $f(i, j)$ 表示 $i$ 和 $j$ 两个点在同一个连通块的方案数，如果该连通块有连出去的边，则一定有 $f(i, j)=0$，该连通块的贡献就是 $f(i, j)$ 乘上其他点随便连边的方案数</p><p>对于后面的东西，设 $g(x)$ 表示 $x$ 个点两两连边的方案数，$g$ 有以下转移</p><script type="math/tex; mode=display">g(x)=\begin{cases}0&x\mod 2 = 1\\g(x - 2)\times(x-1)&x\mod 2=0\end{cases}</script><p>下面考虑 $f$ 的转移，可以容斥一下（$Sum(l, r)$ 表示 $[l,r]$ 里能自由连边的点）</p><script type="math/tex; mode=display">f(l, r)=\begin{cases}0&(r-l+1)\mod 2=1\\g(Sum(l, r))-\sum_{k=l}^{r-1}f(l, k)\times g(Sum(k+1, r))&else\end{cases}</script><p>然后答案就是</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i+2}^nf(i, j)\times g(n - 2 * K-Sum(i, j))</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair <span class="hljs-string">&lt; int, int &gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for (int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">605</span>)</span>, <span class="hljs-title">Mod</span><span class="hljs-params">(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)</span></span>;<br><span class="hljs-type">int</span> N, K, Buc[kN];<br><span class="hljs-type">int</span> F[kN][kN], G[kN];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N &gt;&gt; K; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K, x, y) IN &gt;&gt; x &gt;&gt; y, Buc[x] = y, Buc[y] = x;<br>N &lt;&lt;= <span class="hljs-number">1</span>;<br>G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i += <span class="hljs-number">2</span>) G[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) G[i - <span class="hljs-number">2</span>] * (i - <span class="hljs-number">1</span>) % Mod;<br><span class="hljs-comment">//IR(i, 1, N) cout &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; G[i] &lt;&lt; &quot;\n&quot;;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">Len</span>(<span class="hljs-number">2</span>); Len &lt;= N; Len += <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">IR</span>(L, <span class="hljs-number">1</span>, N - Len + <span class="hljs-number">1</span>) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">R</span><span class="hljs-params">(L + Len - <span class="hljs-number">1</span>)</span>, <span class="hljs-title">C</span><span class="hljs-params">(Len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-built_in">IR</span>(k, L, R) <span class="hljs-keyword">if</span> (Buc[k] <span class="hljs-built_in">and</span> (--C, Buc[k] &lt; L <span class="hljs-keyword">or</span> Buc[k] &gt; R)) &#123; flag = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>; &#125;<br><span class="hljs-comment">//cout &lt;&lt; L &lt;&lt; &quot; -&gt; &quot; &lt;&lt; R &lt;&lt; &quot; : &quot; &lt;&lt; (flag ? &quot;NO &quot; : &quot;OK&quot;) &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">continue</span>;<br>F[L][R] = G[C];<br><span class="hljs-comment">//IR(k, L, R - 1, D(0)) &#123;</span><br><span class="hljs-built_in">OR</span>(k, R, L + <span class="hljs-number">1</span>, <span class="hljs-built_in">D</span>(<span class="hljs-number">0</span>)) &#123;<br>D += !Buc[k];<br>F[L][R] = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[L][R] - (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[L][k - <span class="hljs-number">1</span>] * G[D] % Mod + Mod) % Mod;<br>&#125;<br>Ans = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) Ans + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[L][R] * G[N - (K &lt;&lt; <span class="hljs-number">1</span>) - C] % Mod) % Mod;<br>&#125;<br>&#125;<br><br>cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>模拟赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟赛</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-03-08 模拟赛题解</title>
    <link href="/2022/03/08/2022-03-08-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/08/2022-03-08-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-03-08-模拟赛题解"><a href="#2022-03-08-模拟赛题解" class="headerlink" title="2022-03-08 模拟赛题解"></a>2022-03-08 模拟赛题解</h1><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>考虑不可能给排名更低的队伍送气球，且如果排名更高的队伍送气球一定会送到炸。</p><p>所以考虑先对其他队伍按照气球数从大到小排序，然后建一个小根堆，按照送气球到炸的数量重载小于号，将排名高于我们的队伍都放到堆里，每次取出堆顶处理一下就做完了。</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>考虑对于每一条边分别处理贡献，因此我们只需要知道每一条边走了多少次，维护两个树上差分数组即可。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>考虑把直径拎出来，如果拆分出来的边不在直径上，对答案的贡献一定还是直径。</p><p>如果拆分的边在直径上，就会分成左右两部分。单独考虑左边的情况（右边同理），根据直径的定义，左边的新直径的左端点一定是原先直径的左端点（否则与直径是最长的路径矛盾），然后对于每一个直径上的点记录自己到子树内的最长链长度，接着求出左端点到这个点的路径长度和自己的最长链长度求和，然后更新最大值即可。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>模拟赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟赛</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分入门</title>
    <link href="/2022/03/04/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%85%A5%E9%97%A8/"/>
    <url>/2022/03/04/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="微积分入门"><a href="#微积分入门" class="headerlink" title="微积分入门"></a>微积分入门</h1><p>详见 3blue1brown 的微积分视频。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>微积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论入门</title>
    <link href="/2022/03/01/%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2022/03/01/%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="博弈论入门"><a href="#博弈论入门" class="headerlink" title="博弈论入门"></a>博弈论入门</h1><h2 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h2><p>公平组合游戏是指满足以下性质的游戏：</p><ul><li>游戏有且仅有两人，轮流操作。</li><li>双方在任意时刻的决策集合仅和时刻的状态有关，和决策者无关。</li></ul><h2 id="Nim-游戏"><a href="#Nim-游戏" class="headerlink" title="Nim 游戏"></a>Nim 游戏</h2><p>有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个。两名玩家轮流取走某一堆的若干个石子，可以取完但是不能不取，最后不能取石子的玩家判负，问先手是否有必胜策略。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>若 $a_1\oplus a_2\oplus \cdots\oplus a_n\not ={0}$ 先手必胜，否则先手必败。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>若存在一个局面的异或和不为 $0$，设当前异或和二进制表示下最高位的位数为 $k$，根据异或定义，一定有奇数个数在二进制的 $k$ 位上值为 $1$，所以一定存在一个 $a_i&gt;2^k$，可以从第 $i$ 堆里拿出 $a_i-2^k$ 个石子使得异或和为 $0$。</p><p>若当前局面异或和为 $0$，则一定不存在一种方案使得取完石子后异或和仍未零。可以使用反证法。设</p><script type="math/tex; mode=display">a_1\oplus\cdots\oplus a_i\oplus\cdots\oplus a_n = 0</script><p>若命题不成立，则可以在 $a_i$ 中取 $k$ 个石子使得异或和仍未零，则会有</p><script type="math/tex; mode=display">a_1\oplus\cdots\oplus (a_i - k)\oplus\cdots\oplus a_n = a_1\oplus\cdots\oplus a_i\oplus\cdots\oplus a_n = 0</script><p>根据异或的性质可以把无关项消掉，得到</p><script type="math/tex; mode=display">a_i=a_i-k\Rightarrow k=0</script><p>这与不取石子的规则相违背，故原命题成立。</p><h2 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h2><p>考虑到公平组合游戏千差万别，对于每一种游戏都想出一个类似于 Nim 游戏的精巧证明并不容易，所以我们引入了 SG 函数。</p><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>首先举一个 Nim 游戏的例子。有四堆石子 $1,2,3,7$。考虑将母问题拆分成四个子问题。</p><p>对于第一堆石子，只能取 $1$ 个把它变成 $0$ 从而使得后手必败，我们称这种状态为 <b>一级胜态</b>，第二堆石子只能变成 $0,1$，称其为 <b>二级胜态</b>，以此类推可以得到 $n$ 个石子为 <b>$n$ 级胜态</b>。特别的，将 <b>$0$</b> 称作 <b>终态</b>，终态不可继续操作。</p><p>然后定义一个胜态为 $n$ 级胜态，当其可以变为 $[1,n-1]$ 中的所有等级胜态时。同时定义 $\operatorname{mex}$ 函数为找出一个非负整数集合里<b>未出现过</b>的<b>最小</b>非负整数值。</p><p>然后我们考虑给这个类似于函数的<b>胜态级别</b>取一个高端大气的名字…就叫 $SG$ 函数吧！</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><!-- 对于任何一个母问题，都可以将其转化为两部分子问题。设母问题为 $X$，其可以分为 $A$ 和 $B$ 两个子问题。- 如果 $A$ 和 $B$ 均为先手必败的局面，此时无论先手如何操作都只能将局面变为一个先手必胜一个先手必败的局面（类比 Nim 游戏）。此时后手只需将必胜局面变为必败局面就可以将问题变回原样，直至 $A$ 和 $B$ 都为终态为止。所以此时先手必败。- 如果 $A$ 为先手必败，$B$ 为先手必胜，此时先手只需将 $B$ 变成先手必败状态，即可让后手进入第一种情况，所以此时先手必胜。- 如果 $A$ 和 $B$ 均为先手必胜，先手一定不能将局面转化为第二种情况，否则必败。所以在这种情况时，我们需要知道关于 $A$ 和 $B$ 更加详细的信息才能得知结果。 --><p>首先根据定义我们有</p><script type="math/tex; mode=display">SG(A)=\operatorname{mex}(SG(B)|A\rightarrow B)</script><p>然后定义一种运算 $@$ 表示将两个子问题合在一起，由基本事实可以得到：</p><ul><li>$SG(A@B@C)=SG(A@(B@C))$</li><li>$SG(A @ 0)=SG(A)$，因为一个空的子问题对答案没有影响。</li><li>$SG(A@A)=0$，因为两个相同的子问题无论先手如何操作后手都可以复制，所以先手必败。</li></ul><p>根据观察可以发现 $@$ 这种运算和 $\oplus$ 很相似，接下来我们将通过严谨的证明来说明 $@$ 和 $\oplus$ 是等价的。</p><p>由定义可知</p><script type="math/tex; mode=display">SG(A@B)=\operatorname{mex}(\{SG(C)|A\rightarrow C\}\{SG(D)|B\rightarrow D\})</script><p>如果要证明 $@\Leftrightarrow\oplus$，只需证明</p><ol><li>$SG(A)\oplus SG(B)\not\in\{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}$</li><li>$\forall E &lt; SA(A)\oplus SG(B)$，都有 $E\in \{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}$。</li></ol><p>对于第一个式子：</p><script type="math/tex; mode=display">\begin{aligned}&\because A\rightarrow C,~B\rightarrow D\\&\therefore SG(A)\not ={SG(B)},~SG(B)\not ={SG(D)}\\&\therefore SG(A)\oplus SG(B)\not\in\{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}\end{aligned}</script><p>对于第二个式子：</p><p>设 $F=SG(A)\oplus SG(B)\oplus E$，将 $F$ 和组成它的三部分中的一个异或，一定会使得结果变小（因为 $F$ 最高位上的 $1$ 一定来自其一），而这个数一定不是 $E$，因为 $F\oplus E=SA(A)\oplus SA(B)&gt;E$（由 $E$ 的定义可知）。</p><p>不妨设 $F\oplus SG(A)&lt;SG(A)$，此时由 $SG(B)\oplus E&lt;SG(A)$，再由 $SG$ 函数额定义可以得到，一定有一个 $A$ 的后继状态 $C$ 使得 $SG(C)=SG(B)\oplus E$，从而有 $E=SB(C)\oplus SG(B)$。</p><p>然后我们就证明了 $\forall E &lt; SA(A)\oplus SG(B)$，都有 $E\in \{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}$。</p><p>总结一下，我们就得到了 $SG$ 函数的两条高明性质：</p><ul><li>$SG(A)=\operatorname{mex}(SG(B)|A\rightarrow B)$</li><li>$SG(A@B)=SG(A)\oplus SG(B)$</li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="GZOI2017-取石子游戏"><a href="#GZOI2017-取石子游戏" class="headerlink" title="[GZOI2017] 取石子游戏"></a>[GZOI2017] 取石子游戏</h3><p>考虑 Nim 游戏的获胜条件，先手必胜当前仅当开始局面异或和为 $0$，为了让阴险的 Alice 不能获胜，有以下两种办法：</p><ul><li>开局异或和为 $0$。</li><li>开局异或和不为 $0$，但是指定的一堆石子数量小于其他石子的异或和。</li></ul><p>第一种情况可以认为是指定的一堆石子必须等于其他石子的异或和，所以我们的任务就是：从 $n$ 堆石子中选择任意堆，从选择的石子堆里面选出一堆，使其数量小于等于选择的其他石子的异或和。</p><p>考虑钦定 Alice 选哪一堆，然后用动态规划求出其余石子异或和大于等于选定石子个数的方案数即可。</p><p>设钦定 Alice 选择第 $i$ 堆石子， $f_{j, k}$ 表示前 $j$ 堆里，异或和等于 $k$ 的方案数，容易得到转移方程：</p><script type="math/tex; mode=display">f_{j,k}=\begin{cases}f_{j-1,k}&i=j\\f_{j-1,k}+f_{j-1,k\oplus A_j}&i\not ={j}\end{cases}</script><p>分两种情况的原因是钦定的石子堆是不能用来转移的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-comment">//#define int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">222</span>)</span>, <span class="hljs-title">kV</span><span class="hljs-params">(<span class="hljs-number">257</span>)</span>, <span class="hljs-title">Mod</span><span class="hljs-params">(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)</span></span>;<br><span class="hljs-type">int</span> N, A[kN], Ans;<br><span class="hljs-type">int</span> F[kN][kV];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  IN &gt;&gt; N; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) IN &gt;&gt; A[i];<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) &#123;<br><span class="hljs-built_in">FL</span>(F, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> F);<br>F[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br><span class="hljs-built_in">IR</span>(j, <span class="hljs-number">1</span>, N) &#123;<br><span class="hljs-built_in">IR</span>(k, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>) &#123;<br><span class="hljs-keyword">if</span> (i == j) F[j][k] = F[j - <span class="hljs-number">1</span>][k];<br><span class="hljs-keyword">else</span> F[j][k] = (F[j - <span class="hljs-number">1</span>][k] + F[j - <span class="hljs-number">1</span>][k ^ A[j]]) % Mod;<br>&#125;<br>&#125;<br><span class="hljs-built_in">IR</span>(j, A[i], <span class="hljs-number">255</span>) Ans = (Ans + F[N][j]) % Mod;<br>&#125;<br>cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-03-01 模拟赛题解</title>
    <link href="/2022/03/01/2022-03-01-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/01/2022-03-01-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-03-01-模拟赛题解"><a href="#2022-03-01-模拟赛题解" class="headerlink" title="2022-03-01 模拟赛题解"></a>2022-03-01 模拟赛题解</h1><p><a href = 题面.zip>题面</a></p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>输入/输出优化模板（虽然 cin + string + deque） 的常数都过了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(unsigned int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(unsigned int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(unsigned int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-type">char</span> buf[(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>) + <span class="hljs-number">100</span>], *p, *e;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getChar</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (p == e) p = buf, e = buf + <span class="hljs-built_in">fread</span>(buf, <span class="hljs-number">1</span>, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>), stdin);<br><span class="hljs-keyword">return</span> p == e ? EOF : *p++;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br><span class="hljs-type">char</span> c, l;<br><span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>; !<span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getChar</span>()) l = c;<br><span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; <span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getChar</span>()) x = x * <span class="hljs-number">10</span> - <span class="hljs-string">&#x27;0&#x27;</span> + c;<br><span class="hljs-keyword">if</span> (l == <span class="hljs-string">&#x27;-&#x27;</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (T x) &#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">10</span>) *<span class="hljs-keyword">this</span> &lt;&lt; x / <span class="hljs-number">10</span>;<br><span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kN = <span class="hljs-number">1e5</span> + <span class="hljs-number">15</span>, kM = <span class="hljs-number">1e7</span> + <span class="hljs-number">17</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> N, P;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> A[kN];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> Ans[kM];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Top;<br>deque &lt; <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> &gt; Q;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Opt[kM];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) IN &gt;&gt; A[i];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; IN &gt;&gt; P;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, P) &#123;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Opt</span><span class="hljs-params">(IN.getChar())</span></span>;<br><span class="hljs-keyword">while</span> (Opt &lt; <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> Opt &gt; <span class="hljs-string">&#x27;4&#x27;</span>) IN.<span class="hljs-built_in">getChar</span>();<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">op</span><span class="hljs-params">(Opt - <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>Q.<span class="hljs-built_in">push_back</span>(A[cnt]);<br><span class="hljs-keyword">if</span> (++cnt == N + <span class="hljs-number">1</span>) cnt = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>Ans[++Top] = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop_front</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>Ans[++Top] = Q.<span class="hljs-built_in">back</span>(); Q.<span class="hljs-built_in">pop_back</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">IR</span>(j, <span class="hljs-number">1</span>, Top) &#123;<br><span class="hljs-keyword">if</span> (flag <span class="hljs-keyword">and</span> Ans[j] != <span class="hljs-number">0</span>) flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>) IN &lt;&lt; Ans[j];<br>&#125;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>Top = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>状态压缩 DP，但是我不会 awa。</p><p>设 $f(i,j)$ 表示最后一个任务点为 $i$，已经做完的任务集合为 $j$ 时的答案， $g(i, j)$ 表示达到 $f(i, j)$ 答案时的最短时间。</p><p>枚举下一个走到的任务点转移即可（要注意当 $f$ 变大时，$g$ 不能取较小值而应该直接复制）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">222</span>)</span>, <span class="hljs-title">kK</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-type">int</span> N, M, K;<br><span class="hljs-type">int</span> Mp[kN][kN];<br><span class="hljs-type">int</span> F[<span class="hljs-number">20</span>][kK], G[<span class="hljs-number">20</span>][kK];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NODE</span> &#123;<br><span class="hljs-type">int</span> u, l, r, t, c;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">In</span><span class="hljs-params">()</span> </span>&#123; IN &gt;&gt; u &gt;&gt; l &gt;&gt; r &gt;&gt; t &gt;&gt; c; &#125;<br>&#125; D[kN];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N &gt;&gt; M; <span class="hljs-built_in">FL</span>(Mp, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> Mp); <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) Mp[i][i] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, M, x, y, z) IN &gt;&gt; x &gt;&gt; y &gt;&gt; z,<br>Mp[x][y] = <span class="hljs-built_in">min</span>(Mp[x][y], z), Mp[y][x] = <span class="hljs-built_in">min</span>(Mp[y][x], z);<br>IN &gt;&gt; K; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K) D[i].<span class="hljs-built_in">In</span>();<br><span class="hljs-built_in">IR</span>(k, <span class="hljs-number">1</span>, N) <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) <span class="hljs-built_in">IR</span>(j, <span class="hljs-number">1</span>, N)<br>Mp[i][j] = <span class="hljs-built_in">min</span>(Mp[i][j], Mp[i][k] + Mp[k][j]);<br><span class="hljs-comment">//IR(i, 1, N) IR(j, 1, N) cout &lt;&lt; i &lt;&lt; &quot; -&gt; &quot; &lt;&lt; j &lt;&lt; &quot; : &quot; &lt;&lt; Mp[i][j] &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-built_in">FL</span>(F, <span class="hljs-number">0xcf</span>, <span class="hljs-keyword">sizeof</span> F), <span class="hljs-built_in">FL</span>(G, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> G);<br>F[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = G[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">IR</span>(S, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; K) - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K) &#123;<br><span class="hljs-built_in">IR</span>(k, <span class="hljs-number">1</span>, K) &#123;<br><span class="hljs-keyword">if</span> ((S &gt;&gt; (k - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">To</span><span class="hljs-params">(D[k].u)</span>, <span class="hljs-title">Fr</span><span class="hljs-params">(D[i].u)</span></span>;<br><span class="hljs-keyword">if</span> (G[i][S] + Mp[Fr][To] &gt; D[k].r) <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//RE();</span><br><span class="hljs-keyword">if</span> (F[i][S] + D[k].c &gt; F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))]) &#123;<br>F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))] = <span class="hljs-built_in">max</span>(<br>F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))],<br>F[i][S] + D[k].c<br>);<br>G[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))] = <span class="hljs-built_in">max</span>(D[k].l, G[i][S] + Mp[Fr][To]) + D[k].t;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (F[i][S] + D[k].c == F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))]) &#123;<br>G[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))] = <span class="hljs-built_in">min</span>(<br>G[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))],<br><span class="hljs-built_in">max</span>(D[k].l, G[i][S] + Mp[Fr][To]) + D[k].t<br>);<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(-INF)</span></span>;<br><span class="hljs-built_in">IR</span>(S, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; K) - <span class="hljs-number">1</span>) <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K) ans = <span class="hljs-built_in">max</span>(ans, F[i][S]);<br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">TE</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>还不会…</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>模拟赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟赛</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式笔记</title>
    <link href="/2022/02/28/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/28/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="多项式笔记"><a href="#多项式笔记" class="headerlink" title="多项式笔记"></a>多项式笔记</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义 $n$ 次多项式 $f(x)=\sum_{i=0}^na_ix^i$，称其最高项系数的次数为该多项式的度，记作 $\deg f$。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>定义如下多项式</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^na_ix^i\\g(x)=\sum_{i=0}^nb_ix^i\\</script><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><script type="math/tex; mode=display">f(x)+f(y)=\sum_{i=0}^n(a_i+b_i)x^i</script><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><script type="math/tex; mode=display">f(x)-f(y)=\sum_{i=0}^n(a_i-b_i)x^i</script><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><script type="math/tex; mode=display">f(x)\cdot g(x)=\sum_{i=0}^n\sum_{j=0}^na_ib_jx^{i+j}</script><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>若存在唯一的 $Q(x),~R(x)$ 满足</p><script type="math/tex; mode=display">f(x)=Q(x)g(x)+R(x)\\\deg R < \deg g</script><p>若 $\deg f &gt; \deg g$，此时 $\deg Q=\deg  f-\deg g$，否则有 $Q(x)=0$。称 $Q(x)$ 为 $f(x)$ 除以 $g(x)$ 的商， $R(x)$ 为 $f(x)$ 除以 $g(x)$ 的余数，也可以记作</p><script type="math/tex; mode=display">f(x)\equiv R(x)(mod~g(x))</script><h2 id="朗格拉日插值"><a href="#朗格拉日插值" class="headerlink" title="朗格拉日插值"></a>朗格拉日插值</h2><p>由初中数学可以知道，如果给定平面上的 $n$ 个点，则可以唯一确定一个 $n-1$ 次的多项式（如两点确定一个一次多项式，三点确定一个二次多项式），如果要求出该多项式每一项的系数，可以使用高斯消元法， 时间复杂度为 $O(n^3)$，时间复杂度过高。</p><p>朗格拉日插值法使用构造的方式在 $O(n^2)$ 求解多项式系数。</p><p>首先构造 $n$ 个函数，其中第 $i$ 个函数 $f_i(x)$ 满足<br>$<br>f_i(x)=\begin{cases}<br>0&amp; (x\not=x_i)\\<br>y_i&amp; (x= x_i)<br>\end{cases}<br>$  </p><p>最后要求的多项式 $f(x)=\sum_{i=1}^nf_i(x)$。<br>可以设</p><script type="math/tex; mode=display">f_i(x)=a\cdot\prod_{j\not=i}(x-x_j)</script><p>将 $f_i(x_i)=y_i$ 代入得到</p><script type="math/tex; mode=display">a=\frac{y_i}{\prod_{j\not ={i}}}(x_i-x_j)</script><p>所以</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^ny_i\prod_{j\not ={i}}\frac{x-x_j}{x_i-x_j}</script><h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><p>多项式的加法和减法按照定义都可以在 $O(n)$ 的时间复杂度内解决，但是多项式乘法的朴素算法是 $O(n^2)$ 的，所以我们引入了<b>快速傅里叶变换（FFT）</b>。</p><p>为了方便，下文默认相乘的两个多项式的度数均为 $n$。</p><h3 id="多项式表示法"><a href="#多项式表示法" class="headerlink" title="多项式表示法"></a>多项式表示法</h3><p>一个 $n$ 次多项式可以视作一个 $n$ 次函数的解析式，它可以用平面直角坐标系内不重复的 $n + 1$ 个点唯一表示。前者被称为<b>系数表示法</b>，后者被称为<b>点值表示法</b>。</p><script type="math/tex; mode=display">f(i)=a_0+a_1x^1+\cdots+a_nx^n\Leftrightarrow\{(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)\}\\g(i)=b_0+b_1x^1+\cdots+b_nx^n\Leftrightarrow\{(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)\}</script><p>然后就有</p><script type="math/tex; mode=display">f(x)\cdot g(x)=\sum_{i=0}^n\sum_{j=0}^na_ib_jx^{i+j}\Leftrightarrow\{(x_0, f(x_0)g(x_0)), (x_1, f(x_1)g(x_1)), \cdots, (x_n, f(x_n)g(x_n))\}</script><p>将系数表示法转化为点值表示法的过程叫做<b>离散傅里叶变换（DFT）</b>，相反的变换成为<b>离散傅里叶逆变换（IDFT）</b>。</p><h3 id="复根"><a href="#复根" class="headerlink" title="复根"></a>复根</h3><!-- ![](https://oi-wiki.org/math/poly/images/fft3.png) --><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>我们称 $x^n=1$ 的根是 $n$ 次复根，这样的根共有 $n$ 个。记 $\omega_n=e^{\frac{2\pi i}{n}}$，则 $x^n=1$ 的解集为 $\{w_n^k|k\in [0, n-1]\}$，由复平面的知识可以知道，$n$ 次单位复根是把复平面上的单位元分成 $n$ 份第一个角所对应的向量，其他的复根可以用单位复根的幂次表示。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>根据三角函数和向量的有关内容可以知道</p><script type="math/tex; mode=display">\omega_n=\cos(\frac{2\pi}{n})+i\cdot \sin(\frac{2\pi}{n})</script><p>根据定义可以得知</p><script type="math/tex; mode=display">\omega_n^n=1\\\omega_n^k=\omega_{2n}^{2k}\\\omega_n^{k+n}=-\omega_n^k</script><h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><p>快速傅里叶变换使用分治的思想进行 DFT 和 IDFT。</p><h4 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h4><p>举个例子，对于一共 $8$ 项的多项式</p><script type="math/tex; mode=display">f(x)=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7</script><p>按照奇偶将其分开</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7\\&=(a_0+a_2x^2+a_4x^4+a_6x^6)+x(a_1+a_3x^2+a_5x^4+a_7x^6)\end{aligned}</script><p>建立两个新的函数</p><script type="math/tex; mode=display">G(x)=a_0+a_2x+a_4x^2+a_6x^3\\H(x)=a_1+a_3x+a_5x^2+a_7x^3</script><p>根据单位复根的性质可以得到</p><script type="math/tex; mode=display">\begin{aligned}DFT(f(\omega_n^k))&=DFT(G(\omega_n^k)^2)+\omega_n^k\cdot DFT(H(\omega_n^k)^2)\\&=DFT(G(\omega_n^{2k}))+w_n^k\cdot DFT(H(\omega_n^{2k}))\\&=DFT(G(\omega_{\frac{n}{2}}^{k}))+w_n^k\cdot (H(\omega_{\frac{n}{2}}^{k}))\end{aligned}</script><p>同理可得</p><script type="math/tex; mode=display">DFT(f(\omega_n^k))=DFT(G(\omega_{\frac{n}{2}}^{k}))-w_n^k\cdot (H(\omega_{\frac{n}{2}}^{k}))</script><p>发现如果我们能求出 $DFT(G(x))$ 和 $DFT(H(x))$ 的话，就可以求解 $DFT(f(x))$。因此，我们可以分治求解 DFT。</p><p>注意，当我们使用分治 DFT 的时候，要使得原多项式的项数保持在 $2^m-1$ 的状态，否则会导致右边系数缺失。</p><h4 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h4><p>设原有多项式为 $f(x)=\sum_{i=0}^{n-1}a_ix^i$，我们已经知道了横坐标均为 $n$ 次复根的点值表示法，需要求 $f(x)$ 的系数表示法。</p><p>考虑使用构造法。设 $y_i=f(w_n^i)$，构造多项式如下</p><script type="math/tex; mode=display">A(x)=\sum_{i=0}^{n-1}y_ix_i</script><p>这就相当于把 $f(x)$ 点值表示法的纵坐标当作 $A(x)$ 系数表示法的系数。</p><p>设 $b_i=\omega_n^{-i}$，则 $A(x)$ 的点值表示法为 $\{(b_0, A(b_0)),(b_1, A(b_1)),\cdots,(b_{n-1}, A(b_{n-1}))\}$。</p><p>然后推一下式子</p><script type="math/tex; mode=display">\begin{aligned}A(b_k)&=\sum_{i=0}^{n-1}y_i\omega_n^{-ik}\\&=\sum_{i=0}^{n-1}\omega_n^{-ik}\sum_{j=0}^{n-1}a_j(\omega_n^i)^j\\&=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}\omega_n^{-ik}a_j(\omega_n^i)^j\\&=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}(\omega_n^{j-k})^i\end{aligned}</script><p>设 $S(\omega_n^a)$ 表示 $\sum_{i=0}^{n-1}(\omega_n^a)^i$。</p><p>当 $a=0$ 时，$S(\omega_n^a)=n$。<br>当 $a\not ={0}$ 时，</p><script type="math/tex; mode=display">\begin{aligned}S(\omega_n^a)&=\sum_{i=0}^{n-1}(\omega_n^a)^i\\(\omega_n^a)^nS(\omega_n^a)&=\sum_{i=1}^{n}(\omega_n^a)^i\\\omega_n^aS(\omega_n^a)&=\sum_{i=1}^{n}(\omega_n^a)^i\\\end{aligned}</script><p>做差可得</p><script type="math/tex; mode=display">S(\omega_n^a)=\frac{(\omega_n^a)^n-(\omega_n^a)^0}{\omega_n^a-1}=\frac{(\omega_n^n)^a-(\omega_n^a)^0}{\omega_n^a-1}=\frac{1-1}{\omega_n^a-1}=0\\</script><p>整理可得</p><script type="math/tex; mode=display">S(\omega_n^a)=\begin{cases}n&a=0\\0&a\not=0\end{cases}</script><p>所以</p><script type="math/tex; mode=display">A(b_k)=\sum_{i=0}^{n-1}a_jS(\omega_n^{j-k})=\sum_{i=0}^{n-1}a_j\cdot n</script><p>所以此时 $A$ 的点值表示法为 $\{(b_0, a_0\cdot n),(b_1, a_1\cdot n),\cdots,(b_{n-1},a_{n-1}\cdot n)\}$。再使用 FFT 对多项式 $A$ 进行一边 DFT，将其点值表示法纵坐标都除以 $n$ 即可得到 $f$ 的系数表示法。</p><h4 id="蝴蝶变换"><a href="#蝴蝶变换" class="headerlink" title="蝴蝶变换"></a>蝴蝶变换</h4><p>快速傅里叶变换的时间复杂度已经是 $O(nlogn)$，但是由于递归和动态申请空间的常数很有可能会 TLE，所以可以使用迭代替代递归，蝴蝶变换代替动态申请空间使得常数变低。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><span class="hljs-keyword">typedef</span> complex &lt; <span class="hljs-type">double</span> &gt; Comp;<br><span class="hljs-function"><span class="hljs-type">const</span> Comp <span class="hljs-title">I</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> <span class="hljs-title">PI</span><span class="hljs-params">(acos(<span class="hljs-number">-1</span>))</span></span>;<br><br><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">4e6</span> + <span class="hljs-number">16</span>)</span></span>;<br><span class="hljs-type">int</span> N, M, <span class="hljs-built_in">Lim</span>(<span class="hljs-number">1</span>);<br>Comp F[kN], G[kN];<br><span class="hljs-type">int</span> Rev[kN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Change</span><span class="hljs-params">(Comp y[], <span class="hljs-type">int</span> Len)</span> </span>&#123;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Len - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (i &lt; Rev[i]) <span class="hljs-built_in">swap</span>(y[i], y[Rev[i]]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Comp y[], <span class="hljs-type">int</span> Len, <span class="hljs-type">int</span> On)</span> </span>&#123;<br><span class="hljs-built_in">Change</span>(y, Len);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">h</span>(<span class="hljs-number">2</span>); h &lt;= Len; h &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-function">Comp <span class="hljs-title">times</span><span class="hljs-params">(cos(<span class="hljs-number">2</span> * PI / h), sin(On * <span class="hljs-number">2</span> * PI / h))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt; Len; j += h) &#123;<br><span class="hljs-function">Comp <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(j); k &lt; j + h / <span class="hljs-number">2</span>; k++) &#123;<br><span class="hljs-function">Comp <span class="hljs-title">u</span><span class="hljs-params">(y[k])</span>, <span class="hljs-title">t</span><span class="hljs-params">(w * y[k + h / <span class="hljs-number">2</span>])</span></span>;<br>y[k] = u + t, y[k + h / <span class="hljs-number">2</span>] = u - t;<br>w *= times;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (On == <span class="hljs-number">-1</span>) <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Len - <span class="hljs-number">1</span>) y[i] = <span class="hljs-built_in">Comp</span>(y[i].<span class="hljs-built_in">real</span>() / Len, y[i].<span class="hljs-built_in">imag</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N &gt;&gt; M; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, N, x) IN &gt;&gt; x, F[i] = x;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, M, x) IN &gt;&gt; x, G[i] = x;<br><span class="hljs-keyword">while</span> (Lim &lt;= N + M) Lim &lt;&lt;= <span class="hljs-number">1</span>, Log++;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Lim <span class="hljs-number">-1</span>) Rev[i] = (Rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) &lt;&lt; (Log - <span class="hljs-number">1</span>));<br><span class="hljs-built_in">FFT</span>(F, Lim, <span class="hljs-number">1</span>), <span class="hljs-built_in">FFT</span>(G, Lim, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Lim) F[i] *= G[i];<br><span class="hljs-built_in">FFT</span>(F, Lim, <span class="hljs-number">-1</span>);<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, N + M) cout &lt;&lt; (<span class="hljs-type">int</span>) (F[i].<span class="hljs-built_in">real</span>() + <span class="hljs-number">0.5</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 四舍五入防止精度误差</span><br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反演浅谈</title>
    <link href="/2022/02/27/%E5%8F%8D%E6%BC%94/"/>
    <url>/2022/02/27/%E5%8F%8D%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<!-- <font size=6><center><b>反演浅谈</b></center></font> --><!-- <h1 style="border-style:none;text-align:center;">反演浅谈</h1> --><h1 id="反演浅谈"><a href="#反演浅谈" class="headerlink" title="反演浅谈"></a>反演浅谈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果有离散函数 $f$ 能推导出 离散函数 $g$，则称这个过程为“演绎”，如果我们知道了演绎的过程，想通过 $g$ 推出 $f$，这个过程通常称作“反演”。</p><p>如果两函数没有特殊性质，反演只能通过高斯消元求解，但是如果函数之间满足某种特定关系，则可以使用某些特定方式进行求解。</p><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><script type="math/tex; mode=display">g_n=\sum_{i=0}^n\binom{n}{i}f_i\iff f_n=\sum_{i=0  }^n(-1)^{n-i}\binom{n}{i}g_i</script><p>左边为演绎过程，右边为反演过程。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>先将左边带入右边，</p><script type="math/tex; mode=display">\sum_{i=0}^n(-1)^{n-i}\binom{n}{i}g_i=\sum_{i=0}^n(-1)^{n-i}\binom{n}{i}\sum_{j=0}^i\binom{n}{j}f_j</script><p>考虑交换枚举顺序（交换之前可以认为是在逐行枚举杨辉三角，交换之后可以视作按列枚举杨辉三角），</p><script type="math/tex; mode=display">\sum_{j=0}^n\sum_{i=j}^n(-1)^{n-i}\binom{n}{i}\binom{i}{j}f_j</script><p>将中间的组合数拆开来算，</p><script type="math/tex; mode=display">\binom{n}{i}\binom{i}{j}=\frac{n!}{i!(n-i)!}\cdot\frac{i!}{j!(i-j)!}=\frac{n!}{j!(n-j)!}\cdot\frac{(n-j)!}{(n-i)!(i-j)!}=\binom{n}{j}\binom{n-j}{n-i}</script><p>原式等于</p><script type="math/tex; mode=display">\sum_{j=0}^n\sum_{i=j}^n(-1)^{n-i}\binom{n}{j}\binom{n-j}{n-i}f_j</script><p>将和 $i$ 无关的提到前面，</p><script type="math/tex; mode=display">\sum_{j=0}^n\binom{n}{j}f_j\sum_{i=j}^n(-1)^{n-i}\binom{n-j}{n-i}</script><p>第二个求和符号改为枚举 $k$，使得 $i=n-k$，</p><script type="math/tex; mode=display">\sum_{j=0}^m\binom{n}{j}f_j\sum_{k=0}^{n-j}(-1)^{k}\binom{n-j}{n-k}</script><p>然后可以分情况讨论，</p><ul><li>如果 $j\not= n$，后面的和式可以使用二项式定理求出和为 $0$。</li><li>如果 $j=n$，和式为 $\binom{n}{n}f_n\cdot 1$。</li></ul><p>所以等式得证。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>看几个例子吧。</p><h4 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h4><p>起初 $n$ 个物品一一对应地放进 $n$ 个盒子里，然后打乱顺序，问任意物品都不在原来位置的方案数。</p><p>设 $f_i$ 表示有 $i$ 个物品不在原来位置的方案数， $g_i$ 表示所有的方案数。很容易得到下式</p><script type="math/tex; mode=display">g_i=\sum_{i=0}^n\binom{n}{i}f_i</script><p>根据二项式反演可以得到</p><script type="math/tex; mode=display">f_n=\sum_{i=0}^n(-1)^{n-i}\binom{n}{i}g_i</script><p>注意到 $g_n=n!$，所以</p><script type="math/tex; mode=display">f_n=\sum_{i=0}^n(-1)^{n-i}\frac{n!}{i!(n-i)!}\cdot i!</script><p>略微整理一下</p><script type="math/tex; mode=display">f_n=n!\sum_{i=0}^n\frac{(-1)^{n-i}}{(n-i)!}</script><p>改变一下 $i$ 的含义（令 $i=n-i$），</p><script type="math/tex; mode=display">f_n=n!\sum_{i=0}^n\frac{(-1)^i}{i!}</script><p>然后我们就得到了错排的通项公式！</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h3><p>定义两个数论函数的的卷积 $(f*g)(n):=\sum_{e|n}f(e)g(\frac{n}{e})$。<br>迪利克雷卷积的单位元为 $\varepsilon(n)=[n==1]$。</p><p>卷积运算主要有以下推论：</p><ul><li>$\mu * I = \varepsilon$</li><li>$\varphi * I = Id$</li><li>$\sigma * \mu=I * I * \mu = I * \varepsilon=I$，其中 $\sigma$ 表示约数个数函数。</li></ul><h3 id="反演形式"><a href="#反演形式" class="headerlink" title="反演形式"></a>反演形式</h3><p>若 $g(n)=\sum_{e|b}f(e)$，即 $g=f*I$，根据卷积的推论可以得到</p><script type="math/tex; mode=display">f*I*\mu=g*\mu\Rightarrow f=g*\mu</script><p>若 $g$ 有简洁的通项公式，加之 $\mu$ 可以使用线性筛或者杜教筛等方法，可以在 $O(n)$ 甚至 $O(n^{\frac{2}{3}})$ 的时间内求解 $f(n)$。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开端</title>
    <link href="/2022/02/27/%E5%BC%80%E7%AB%AF/"/>
    <url>/2022/02/27/%E5%BC%80%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>2022-02-27：__Xu128’s Blog 搭建完成！</p>]]></content>
    
    
    <categories>
      
      <category>开端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
