<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Haskell 学习笔记</title>
    <link href="/2022/05/28/Haskell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/28/Haskell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-学习笔记"><a href="#Haskell-学习笔记" class="headerlink" title="Haskell 学习笔记"></a>Haskell 学习笔记</h1><h2 id="GHIC-的基础指令"><a href="#GHIC-的基础指令" class="headerlink" title="GHIC 的基础指令"></a>GHIC 的基础指令</h2><ul><li>在终端输入 $ghic$ 进入。</li><li>$:l\ PATH$ 加载 Haskell 文件。</li><li>$:t\ NAME$ 显示一个函数或变量的类型。</li></ul><h2 id="类型和函数"><a href="#类型和函数" class="headerlink" title="类型和函数"></a>类型和函数</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>$Int$ 普通整数类</li><li>$Word$ 无符号整数类</li><li>$Integer$ 无上限高精度整数类</li><li>$Float$ 单精度浮点数类</li><li>$Double$ 双精度浮点数类</li><li>$Rational$ 有理数类，其中 $%$ 代表分数线</li><li>$Char$，使用单引号包裹的变量</li><li>$字符串类型$，即使用方括号或者双引号包裹的变量</li><li>$元组$，使用圆括号包裹的变量，其内部可以塞入最多 $62$ 个任意类型变量，对于二元元组来说 $fst\ NAME$ 表示其中的第一个元素，$snd\ NAME$ 表示第二个元素</li></ul><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>函数可以认为是一个类型到类型的映射，比如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plane">&gt; let add1(x, y) = (x + y) :: Int<br></code></pre></td></tr></table></figure><br>这样就定义了一个 $add1$ 函数，它接收一个二元元组，返回元组内两个元素的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plane">&gt; add1 (2, 3)<br>5<br></code></pre></td></tr></table></figure><h4 id="柯里化和非柯里化"><a href="#柯里化和非柯里化" class="headerlink" title="柯里化和非柯里化"></a>柯里化和非柯里化</h4><p>柯里化函数，就是将函数所需要的类型一个一个传进去，如果数量不够，则返回需要下一个参数的函数，而非柯里化函数需要一次性传输完毕所有的参数才能刚工作。</p><p>思考 $add1$ 函数所做的事情，它接收一个元组，然后返回它们的和，这就是一个非柯里化函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plane">&gt; :t add1<br>add1 :: (Int, Int) -&gt; Int<br></code></pre></td></tr></table></figure><p>对于柯里化函数我们可以这么定义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plane">&gt; let add2 x y = x + y :: Int<br>&gt; :t add2<br>add2 :: Int -&gt; Int -&gt; Int<br></code></pre></td></tr></table></figure></p><p>如果我们对于一个 $add2$ 只传入一个函数，则它会返回一个只需要一个函数的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plane">&gt; :t add2 1<br>add2 :: Int -&gt; Int<br></code></pre></td></tr></table></figure><p>$add1$ 函数对应着数学语言的 $f(x, y)=x+y$，而 add2 函数如果传入第一个参数 x，则它对应着数学语言的 $f(y)=x+y$，这符合了数学上没有多元函数的原则。</p><h4 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>一个函数的参数可以是任何一个类型的值，那么这个函数就被称为多态函数，$Haskell$ 里的任意一个类型可以用一个以小写字母开头的字符串表示，它被称为类型变量。类型变量是多态的，也就是在使用函数的时候它们可以被替换成其他任何类型（包括其他的多态类型）。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li>$length$ 返回一个列表里元素的个数</li><li>$head$ 返回一个列表里元素的第一个</li></ul><h4 id="重载类型函数"><a href="#重载类型函数" class="headerlink" title="重载类型函数"></a>重载类型函数</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>当对于一个函数使用 $:t$  的时候，可能会出现如下反馈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plane">NAME :: Num a =&gt; a<br></code></pre></td></tr></table></figure><p>其中 $=&gt;$ 是一个类型类的限定符号，意思是说 $NAME$ 有一个类型变量 $a$，但是 $a$ 必须是一个 $Num$ 类型类。</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plane">&gt; :t 5<br>5 :: Num a =&gt; a<br>&gt; :t abs<br>abs :: Num a =&gt; a -&gt; a<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>Haskell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Haskell</tag>
      
      <tag>语言学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-2022年-集训总结</title>
    <link href="/2022/05/22/2021-2022%E5%B9%B4-%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/22/2021-2022%E5%B9%B4-%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong Answer" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e3b4eecf0f20c36d8ba450efb34da6c948a2a9dc3c8c5d7e0b20ab06cd748a89">89e7832c1051f7a3ce3cb672eafab33cf451fe8c691dd1e6a356f8488e5add7a4dae218c9a90f693275f7d55a8a42a358c78353fa415ef8550906f502bc985cf819325b85912244a3eeadcd1fdf1029ae2ea777100069d491d715591730385b6553fd6247e0705f462fc9874748967ad92d32cadce9af05c915a4a5a4287055c2e51aaf3d49b5e02a0642ed058574a429113004431944aa729020ed637d3582ecfc311311aca7be892b34449d12c8bb08d7ee8053ef493bcaefd958ad73df074282c4ed46f743d4c9944fdfeaf3eef63b614a88dfd43c902afda5f1680228ecb8dccac5b6cbe277640f4757ce2321169be972447e3396f6e07ab8b37b0dc2918f75a4f954d15a33cdc74b913c785e5aecc8fa3c957f127b19b55f959e84794fe28853c0969d3cb6023f71f9279a87a1a933d23c89eef23265c43c6f2ab331cd7f07c6e16da5e68e5ed25a9c3678b6b1c57906e3139318bbe6d2bde635f615b38f15acce93646c728d7c1033037be71b33a72c2a29b3753588b67e39f6b512f42bb7b87be52634d5b90b67973c343c57c81b49e4eaf526eeeb2d59b02f3045e5004d85a2a6e4253db0cbe13a6605c3b25f53aad90303032196819f07c9805ab7183763ea28d805a8d736d00237478156a51555ac63a5c7b544f6eaec4d24ab75f2802b62431e349b50db3b9447805d722a998967a81cdae432148926d5137b592e01faad03a2b61c4d664866646d1cc8b69f5b86e9fafa10099d4539ffa6aa5b11d6eb1b868ee65fb3ce6f892a5f9a7ba6a768fcbd4ace4f521bd7a1f3f4841f5f5973e44eac2ffa26d7a56b3c5b3fb435cb48074728687a316a27229cb1a56af8f05db6cd064e4b16b5b1f168a3a60e9abb4fae1e2ca7dcb18aa0f48f514a41dc4d59b5ca2e28f4bfb8bdb2dd85eca1e1dc495cea8b2d0aaa32a44a02670d8db6164dd68faaee8b6efc768e8d75bb60913fdb79ffc4b09efe0f10305558343e145be7c969af61ea8625279e4e834103934f35ecdd9b8b949a593abc0dc2745bda67338224188f8c8431a11ae1f7722ff2467b581db47f8367c1db38a95796083209cbf27968895054cfb0d3a224331c80a53ce3c16f7db2ce4e543cc1b85e731fe7e440d24f8f2cc6e46a119a4b75c3a4f484648c5d835d78cc1ac0a183e645f1d59df9f80dd1c2e5447457ebe7aad0009b632bb5d23ac7c63dd5fbef06afef2ff716c579b3aeabfcc7b1322a90989e08a44c001f16edb420c2f0a25f8e9dbbe68d87c8680ba0e3f95a426a632e14ae1c41d78c2fd5c074fac86867e509ea62c54f2c6c3c88f4d108d7729e8e51cc758225aea1e600ec9235efc964238031e87c22cbafbc82c03537412c477a44b63304000c49c745e8dbbe0551f67b800c58237ded949d49fedd42578d87c4cb93f725fb34d9dcb331e476dd2f6c6544d46e7f2896ae5816b8e3aa7c77c27797a6486066e37a77f61f4c41e076cd584047dc605f4e03682c748934df546cb44fa8aabbdfbadf7acdb6c4543444cc6fbf005749fb7c491fb95725a566e9c4e448d9fe2cf24a3b9330a4c1eab9b4e43a4c3001af3d004fec93759d82eb16eecdaf006d03f9511fccf309ed8960cbba3a9586bc70db30c187a0981488bf282b14a9bb57aff9b29d799ea7354d23f49f4383bd93f1edfdf94b2f8a8818de1200422d7fb3b5766b86dc52dd50090faf83208c269ef932df23c0220cc6e08d7be1b4bd4768777dbc808cc6983b088bf2e71a415873b801e26ff876b4146ac6a42bf089c92f0a533285d2b1710c27ce2530f227675534e26044d0bd6a123ba36ab2bb8be17aa05efb7f59df10dce540aa6beba73a83aa62db96db1261499b8dcd4d150fcd51a8ed87a43f1fa96a630f108bb46b18cf524f22d4136f24165201a087b86f55dc5557bd356116a2a1ea3055b8f2836d4cea49df10ccd76e66d18c99e78cde8f2be191f7770daf4ddf2496e07c5ba2d068398c378497fae06d4cc28df871b0df4cd06527f827e349f324312439131cd2e965189755c56860c45054d35c13d3a5c7952573701ef3cd52b4bb55adaa31059a32fa6c6e28c95ab456f7898c02635176c0ebf4d5674824ff7916b2395b43d87949142e5de57dd01a672a812898b6f441d7809ed4ad231b91e91797bc78899fd0d1f667208c2f79874ad4c3f14d4b7bc5487ff07297467ec434d16d4d0e2dd93738545102b2f5d0982c999195e415ad94ab297c675df1d98cb1c34dffaff15a9c15a11af1ffff29439da246458388d27acd9d45bcd74124a21b5abddd64ee72fd04ffd66d7e96dd791add7ea9ebb03d96854ffe0032156c5be4c0c809b09abe9dd70586f45d2771c951d21e757516bebd2b8b327efdf1e7c6c83b08ac87b5c8eee18b67cc36d07b58ccacba33696a03b7af7006514708f86464eadf2e123bf1e05dbdf67f8cfcbbc2031612917860559e393bebc0709db44837b70282f0d4e6459ccb033548c03fd08180f76cab1064d5a92d0550e4d37323df3dfc13466a9c47e34aa98ffaa5852eb3912373550c779075382233f5f88835eedbda2a3f1f2e6f49cd6021f1655ac64b36f7559b8ea1e0694cf086bc805a7d0149f8beaf57f0639c8a97502a79ee8cbdba4cadfc5e86ed639d80433f70f975af6cea0afc2b11752d598efe919a2385db21fa3c33c8b081f4e72cefc1213cff34dca27010870c7b429e3ee12fcf616060cc61bbb6fb6dcb862493b5c4cc586b21aafd9adda7857d6053e492eb5fd95a76f3ea51d799e7a0ea2033c25ee415ee814ef5c314ccfcffd85bc98aee429ae8a38102b0e03ffcf5c1634233d0531ae46b2ae377d8b5a4c73f6ab484c9ef5d061e41b89d7b34c8064fafbe5cd8d52d32d43f5db4633e00e530ad178e5590b349172274c901ff83205c5b3358690ce9000e6251db19a6507a26972b560ae573b09ea8a8b9f7212549835c6ed330830346125e0a194ea7f3dfc77ebc3b29ece99c349104e82c71f23950538457128a2462ed499b1f7a6a1c0bb53fe79f8153ec207f99728f1bc41d57d1f02abfabab001379188da3292866b90dd8b725ea65e06fb07740a16853dd6914db18a7fa19c951c81dea726c92ad57027e0bb05aeff4317694ad76fa12e2458b02d4dc400ee28df856b02343b391bbc2114460b6bada47ca1e29c9b5dba372406e5731c1a71bf63a6801ebac3291375dc59ac1f0b79e0ebd38ada32794bbae21a2fa8b634ec40f3bd45cc174d28ed8bf2bd1552556dcf9b7a3e65fe4d1f900e6addecbdcf4633e262c0ae4be3b8fa9e985cfa6c48676135a9fd7e6ae60876b481eabcee212d6035630d472af88ee3ec9fb7e77a87b76cf99e0dac054bf00c4d8951e964b3c5bee9dbf5d15e96205e413a96ae3846f5f90e342d4cda284b76a06ca0186ac57f5d31a2b2e3b4cc559fc006fe9d3cc526f6aa354491a427f5a8d79bc73aa1a0e321b1d3540685e84191212fbfc6dd4ee4777f9e21d26e91cea66b7b323eeb6220212253441f6682e73d25a89a2760942fe1a2033c4d3ff133c4676c36ccb3efc8edc108fe185a263185628e7736fa6a0cd07e25dcaa8237122c1ebda7159f12273ec1f9036ce6fde3dde777909a956d7487e7cd84c1450700dc46df1a7d4e82d9631de3902764798a2c1dbf5751b4aab82551277f07c9653c0d3d3d724378a7ade0fae6f8f95f9dbd5aad2c35c8decc660e9448620eb036a19d1eccddd6a029965e588a644bec7a58047ef22857b58f22b3ce2082e766982444f0a001f4a99c178a159191af8899a5d31afa0e168899d2fb8c6b085a6ad1f80b0f1d6ce611d1bf67bc1bd54900c3b95b7f5eb3404897f399a02af91809c2fa1704ca2d7be1e4a2483efc21d422912a930c4587382005f727b28c574f41bf78699b34ede4709ebececcd9f912b0641afcf47ef42dd6cd7023f2dc1c75d1698528db002c9e3a44b5a5836c84ec60fd0ddf204627b5e29f19515027b3b17c89c85b73986ed801673859a35608e71b498f145fe99e84156e0ed4ecd3f3776f0761146e7f9b50e6f2e77db391ab5f54b388b6ccdd3232dcad5d38c4f2143151bde9cf0c6c2469b6edd410f2015e46a5dced82d2a3f02d679b26ada8598e458e5314fb38a58e7d31f8320e9eae2ceae99de1f392cf0b89f9d823b9693ed57013a134e557e5ad096268dbff156f3baf7c04bc18f817e056ce45bf1b09d84688a4176aef183c33c28ff76904b1fbf912efd41be6c47fa351a488c4896bddabc80a1f649aad41017778b2f8abc2aea12b921e3701018b85f0e048025a38e2f403654eeba66d6b6acdc917bcac3cf1dd4f676c485ee06ba9c8c1cf774c132d38f65cc87559b492e0aa76413bffc73f6b7fbb6a394314bdbdf12220ea867b343ba0f5fa0e5486b782608698ed5248eff06ae357f79a39e4652d3b6899cd77c36d00033a637f13ca310a8090118b9c4bf6789ceebd0a3441497327ba13bafe92d406a857577565935938823618c800e0032349a9479ceae7cc45709aad7db4420a6000a0e474ff9d663917d79d451959f687e701a3cd17e6a28932024f1a7f1704da8192af8dc054d43b47db1ddfe7d181a4a42c1a9b078b074150cb1d2c24c40b73c5c2dd925e086a286ea0297877c06dd852e2f9138c87c1734c87eba8a81cbe7e77c7cc892439f85d310573a4d00f8b955401f541cc40cdb8734e14e31bbda14e1dc2f37ac6d953e3efde684c7db2eaa61dd83956e33990b04838d21483f4ca267ac824122c335175c88576ee8a265a2d5ffc2d0633a96bb6cfd502ac7416b67438671959bc4b8dd32451d6578a6233d1ab15d2fef60a402d1895f022e2a2a8d20b96f3e43b6bea0de64d01cbcd732b9b7f33fa91b8821da62b3e64c6af4bfac1118e1948cbe80a34a8b10d5da56dd1ceb68545b7349cc34764f176fd71cfa53a29375a3f9ca99142d9badd22a146755a1a6d10e1cb866da7625935613c246c9e136075c9aac62254faa3d4bc771e4468a1eb81c8d0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">点我输密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学笔记</title>
    <link href="/2022/04/30/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/30/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$\varphi(x)$ 表示 $[1,x-1]$ 中与 $x$ 互质的数的个数.</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>若 $p$ 为质数,则 $\varphi(p^m)=p^{n-1}(p-1)$</li><li>若 $a|x$,则 $\varphi(ax)=a\varphi(x)$</li><li>若 $a\perp b$,则 $\varphi(ab)=\varphi(a)\varphi(b)$</li></ul><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>设正整数 $n=\sum_ip_i^{k_i}$,则 $\varphi(n)=n*\Pi_i\frac{p_i-1}{p_i}$.</p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若 $a\perp m$,则</p><script type="math/tex; mode=display">a^\varphi(m)\equiv 1\ (mod\ m)\\a^b\equiv a^{b\mod \varphi(m)}\ (mod\ m)</script><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>若 $p$ 为质数,则</p><script type="math/tex; mode=display">a^{p-1}\equiv 1\ (mod\ p)\\a^{p-2}\equiv a^{-1}\ (mod\ p)\\</script><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><script type="math/tex; mode=display">(f*g)(n):=\sum_{xy=n}f(x)g(y)</script><p>通常也可写作 </p><script type="math/tex; mode=display">(f*g)(n):=\sum_{d|n}f(d)g(\frac{n}{d})</script><h3 id="其他一些函数"><a href="#其他一些函数" class="headerlink" title="其他一些函数"></a>其他一些函数</h3><ul><li>单位函数 $\varepsilon(n):=\begin{cases}1 &amp; n=1\\0 &amp; \text{otherwise}\end{cases}$</li><li>幂函数 $Id_k(n):=n^k$</li><li>除数函数 $\sigma_k(n):=\sum_{d|n}d^k$</li><li>欧拉函数 $\varphi(n)$</li><li>莫比乌斯函数 $\mu(n)$</li></ul><p>以上函数均为**积性函数**.</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>若 $f$ 和 $g$ 为 积性函数,则 $f*g$ 也是积性函数,证明略.</p><h3 id="除数函数和幂函数"><a href="#除数函数和幂函数" class="headerlink" title="除数函数和幂函数"></a>除数函数和幂函数</h3><p>据定义,有：</p><p>$(f*1)(n)=\sum_{d|n}f(d)1(\frac{n}{d})=\sum_{d|n}f(d)$</p><p>所以：</p><p>$(Id_k*1)(n)=\sum_{d|n}Id_k(d)=\sum_{d|n}d^k$,即 $Id_k*1=\sigma_k$</p><h3 id="欧拉函数和恒等函数"><a href="#欧拉函数和恒等函数" class="headerlink" title="欧拉函数和恒等函数"></a>欧拉函数和恒等函数</h3><p>$(\varphi * 1)(n)=\sum_{d|n}\varphi(n)$</p><p>考虑对于 $n=p^m$（$p$ 为质数）的情况.</p><p>$\sum_{d|n}\varphi(n)=\sum_{i=0}^m\varphi(p^i)=\varphi(1)+\sum_{i=1}^m\varphi(p^i)=p^m=n$</p><p>因为 $\varphi$ 和 $1$ 为积性函数,所以 $(\varphi*1)$ 也为积性函数,所以使用算术基本定理将 $n$ 拆分为若干质数乘积的形式,即可证明 $Id=\varphi*1$.</p><h3 id="莫比乌斯函数和单位函数"><a href="#莫比乌斯函数和单位函数" class="headerlink" title="莫比乌斯函数和单位函数"></a>莫比乌斯函数和单位函数</h3><p>$\mu * 1 = \varepsilon$</p><p>证明略.</p><h3 id="狄利克雷卷积的性质"><a href="#狄利克雷卷积的性质" class="headerlink" title="狄利克雷卷积的性质"></a>狄利克雷卷积的性质</h3><p>满足交换律,结合律和分配律.</p><h2 id="欧拉-莫比乌斯反演"><a href="#欧拉-莫比乌斯反演" class="headerlink" title="欧拉/莫比乌斯反演"></a>欧拉/莫比乌斯反演</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p>$\sum_{i=1}^n\sum_{j=1}^m[(i, j)=1]$\<br>其中 $(a,~b)$ 表示 $a$ 和 $b$ 的最大公因数。</p></blockquote><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^n\sum_{j=1}^m[gcd(i, j)=1]&=\sum_{i=1}^n\sum_{j=1}^m\varepsilon(gcd(i, j))\\&=\sum_{i=1}^n\sum_{j=1}^m(\mu * 1)(gdc(i, j))\\&=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i, j)}\mu(d)\\&=\sum_{d=1}^{\min(n, m)}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\mu(d)\\&=\sum_{d=1}^{\min(n, m)}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}1\\&=\sum_{d=1}^{\min(n, m)}\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\end{aligned}</script><blockquote><p>$\sum_{i=1}^n\sum_{j=1}^m(i, j)$</p></blockquote><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^n\sum_{j=1}^mgcd(i, j)&=\sum_{i=1}^m\sum_{j=1}^m\sum_{d|gcd(i, j)}\varphi(d)\\&=\sum_{d=1}^{\min(n, m)}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(d)\\&=\sum_{d=1}^{\min(n, m)}\varphi(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\\&=\sum_{d=1}^{\min(n, m)}\varphi(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\end{aligned}</script><blockquote><p>$\sum_{i=1}^n\sum_{j=1}^m[i,~j]$\<br>其中 $[a,~b]$ 表示 $a$ 和 $b$ 的最小公倍数。</p></blockquote><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^n\sum_{j=1}^mlcm(i, j)&=\sum_{i=1}^n\sum_{j=1}^m\frac{ij}{(i, j)}\\&=\sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^{gcd(i, j)}[d=(i, j)]\frac{ij}{d}\\&=\sum_{d=1}^{\min(n, m)}\sum_{i=1}^n\sum_{j=1}^m[(i, j)=d]\frac{ij}{d}\\&=\sum_{d=1}^{\min(n, m)}\frac{1}{d}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[(i, j)=1]ij\cdot d^2\\&=\sum_{d=1}^{\min(n, m)}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[(i, j)=1]ij\\&=\sum_{d=1}^{\min(n, m)}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{e|gcd(i, j)}\mu(e)ij\\&=\sum_{d=1}^{\min(n, m)}d\sum_{e=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(e)\sum_{i=1}^{\lfloor\frac{n}{de}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{de}\rfloor}[e|(ie,~je)]ie\times je\\&=\sum_{d=1}^{\min(n, m)}d\sum_{e=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(e)\sum_{i=1}^{\lfloor\frac{n}{de}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{de}\rfloor}ie\times je\\&=\sum_{d=1}^{\min(n, m)}d\sum_{e=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(e) \times e^2\sum_{i=1}^{\lfloor\frac{n}{de}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{de}\rfloor}ij\\&=\sum_{d=1}^{\min(n, m)}d\sum_{e=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(e) \times e^2\sum_{i=1}^{\lfloor\frac{n}{de}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{de}\rfloor}ij\\\end{aligned}</script><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="一些组合恒等式"><a href="#一些组合恒等式" class="headerlink" title="一些组合恒等式"></a>一些组合恒等式</h3><hr><p>以下恒等式**基本**都有组合意义</p><script type="math/tex; mode=display">\binom{n}{k}=\binom{n}{n-k}\\\binom{n}{k}=\frac{n}{k}\binom{j-1}{k-1}\\\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}\\\sum_{l=0}^{n}\binom{l}{k}=\binom{n+1}{k+1},\ n,~k\in N\\\sum_{k=0}^nk\binom{n}{k}=\sum_{k=0}^{n}k\frac{n}{k}\binom{n-1}{k-1}=n\sum_{k=0}^{n}\binom{n-1}{k-1}=n2^{n-1}\\\binom{n}{r}\binom{r}{k}=\binom{n}{k}\binom{n-k}{r-k}\\\sum_{k=0}^{r}\binom{m}{k}\binom{n}{r-k}=\binom{m+n}{r}\\\sum_{k=0}^{m}\binom{m}{k}\binom{n}{k}=\sum_{k=0}^{m}\binom{m}{m-k}\binom{n}{k}=\binom{n+m}{m}\\\sum_{k=0}^{n}\binom{n}{k}^2=\binom{2n}{n}\\</script><h3 id="多项式系数"><a href="#多项式系数" class="headerlink" title="多项式系数"></a>多项式系数</h3><hr><p>$n$ 个不同的球放到 $t$ 个不同的盒子使得第 $i$ 个盒子含 $n_i$ 的方案数为 $\binom{n}{n_1 n_2…n_t}$.</p><p>将 $(x_1+x_2+x_3+…+x_t)^n$ 展开,其 $x_1^{n_1}x_2^{n_2}…x_3^{n_3}$ 项的系数为 $\binom{n}{n_1 n_2…n_t}$.</p><script type="math/tex; mode=display">\binom{n}{n_1n_2n_3...n_t}=\frac{n!}{n_1!n_2!n_3!...n_t!}\\\binom{n}{n_1n_2n_3...n_t}=\binom{n-1}{(n_1-1)n_2...n_t}+\binom{n-1}{n_1(n_2-1)...n_t}+...+\binom{n-1}{n_1n_2...(n_t-1)}</script><h3 id="单调路径问题"><a href="#单调路径问题" class="headerlink" title="单调路径问题"></a>单调路径问题</h3><hr><p>定义：单调路径就是只能向上和向右走的路径.</p><ul><li>从 $(0,\;0)$ 到 $(a,\;b)$  的单调路径数？<ul><li>总共需要走 $a+b$ 步,其中 $a$ 步向右走,答案为 $\binom{a+b}{a}$</li></ul></li><li>从 $(x,\;y)$ 到 $(a,\;b)$  的单调路径数？<ul><li>等价于从 $(0,\; 0)$ 走到 $(a-x,\;b-y)$ ,答案为 $\binom{a-x+b-y}{a-x}$</li></ul></li><li>从 $(x,\;y)$ 经过 $(c,\;d)$ 到 $(a,\;b)$  的单调路径数？<ul><li>使用乘法原理得到答案.</li></ul></li><li>从 $(0,\; 0 )$ 到 $(n, \;n)$ 除端点以外不高于主对角线的单调路径数？<ul><li>使用所有路径减去经过对角线的单调路径即为答案,答案为 $\binom{2n-2}{n-1}-\binom{2n-2}{n}=\frac{1}{n}\times \binom{2n-2}{n-1}$</li></ul></li></ul><h3 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h3><hr><script type="math/tex; mode=display">\binom{n}{m}\equiv\ \prod_i\binom{n_i}{m_i}~\pmod{p}\\\binom{n}{m}=\binom{n\div p}{m\div p}\binom{n\mod p}{m\mod p}\\</script><hr><p>一道组合数的题目链接：[AT2649 11](<a href="https://www.luogu.com.cn/problem/AT2649">https://www.luogu.com.cn/problem/AT2649</a>)</p><p>二道组合数的题目链接： [CF1312D Count the Arrays](luogu.com.cn/problem/CF1312D)</p><h3 id="扩展卢卡斯定理"><a href="#扩展卢卡斯定理" class="headerlink" title="扩展卢卡斯定理"></a>扩展卢卡斯定理</h3><p>该定理适用于求解模数为非质数的组合数.</p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><script type="math/tex; mode=display">\binom{n}{m}\mod q=\frac{n!}{m!(n-m)!}\mod q</script><p>由于模数不一定为质数,所以不能求解分母的逆元,但是可以先对 $q$ 进行质因数分解（设 $p^k$ 为其中一个质因子次幂）,从 $m!$ 和 $(n-m)!$ 中分解出 $p$ 的正整数次幂,使其互质,使用扩展欧几里得算法求解逆元,然后使用中国剩余定理合并即可.</p><script type="math/tex; mode=display">\frac{n!}{m!(n-m)!}\mod p=\frac{n!}{\frac{m!}{p^a}\cdot\frac{(n-m)!}{p^b}}\cdot p^{a+b}\mod p^k</script><p>定义函数 $G(x, p)$ 表示在 $x!$ 中 $p^k$ 的出现次数,注意到该函数的递推式为：</p><script type="math/tex; mode=display">G(x, p) = G(\lfloor\frac{x}{p}\rfloor, p) + \lfloor\frac{x}{p}\rfloor</script><p>该函数可以在 $O(\log_px)$ 的时间复杂度内求解.</p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><hr><p>题目链接：[中国剩余定理(CRT)](<a href="https://www.luogu.com.cn/problem/P1495">https://www.luogu.com.cn/problem/P1495</a>) </p><p>以下为中国剩余定理的前置芝士：</p><h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><p>​        对于任意整数 $a,\;b$,存在一对整数 $x,\;y$,满足$ax+by=gcd(a,b)$.</p><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>​        在欧几里得算法的最后一步,即 $b=0$ 时,显然有整数 $x=1,\;y=0$,使得 $a\times 1 + 0 \times 0 = gcd(a,0)$.</p><p>​        若  $b&gt;0$,则 $gcd(a,b)=gcd(b, a~mod~b)$,假设存在一对整数 $x,y$ 满足 </p><script type="math/tex; mode=display">b\times x+(a~mod~b)\times y = gcd(b, a~mod~b)</script><p>根据模运算的定义展开上式可得：</p><script type="math/tex; mode=display">bx + (a - \lfloor\frac{a}{b}\rfloor b)y=ay+b(x - \lfloor\frac{a}{b}\rfloor y)</script><p>设 $x’=y,~y’=x-\lfloor\frac{a}{b}\rfloor y$,即得到 $ax’+by’=gcd(a, b)$.</p><p>​        对欧几里得算法的递归过程应用数学归纳法,可知裴蜀定理成立.</p><h4 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h4><p>​        裴蜀定理是按照欧几里得算法的思路证明的,且上述证明过程同时给出了整数 $x$ 和 $y$ 的计算方法,这种计算方法被称为**扩展欧几里得算法**.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123; x = <span class="hljs-number">1.</span> y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">Exgcd</span>(b, a % b, x, y);<br>    <span class="hljs-type">int</span> z = x;<br>    x = y, y = z - y * (a / b);<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123; x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">Exgcd</span>(b, a % b, y, x);<br>y -= (a / b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        定义变量 $d, x_0, y_0$,调用 $d=Exgcd(a, b, x, y)$,上述程序就求出了 $ax+by=gcd(a, b)$ 的一组特解$x_0, y_0$,同时返回了 $a$ 和 $b$ 的最大公约数 $d$.</p><p>​        对于更为一般的方程 $ax+by=c$,方程有解当且仅当 $d~|~c$,我们可以先求出其特解,然后令 $x_0, y_0$ 同时乘上 $\frac{c}{d}$,即可求出其他解.</p><p>​        事实上,原方程的通解可以表示为：</p><script type="math/tex; mode=display">x=\frac{c}{d}x_0+k\frac{b}{d},\\y=\frac{c}{d}y_0-k\frac{a}{d}.(k\in \mathbb{Z})\\</script><h4 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h4><p>​        若模数 $p$ 为质数,则可以使用费马小定理直接逆元.</p><p>​        若模数 $p$ 不一定为质数,则可以使用 $\texttt{Exgcd}$ 进行求解.</p><p>转化过程如下：</p><p>​        设 $x$ 为 $a$ 在模 $b$ 意义下的逆元,则</p><script type="math/tex; mode=display">ax\equiv 1~(mod~b)\\</script><p>​        设参数 $y$,上式可以转化为</p><script type="math/tex; mode=display">ax=1-by</script><p>​        移项,得</p><script type="math/tex; mode=display">ax+by=1</script><p>​        上式可以通过 $\texttt{Exgcd}$ 算法求解.</p><p>下面进入中国剩余定理的部分：</p><p>​        中国剩余定理是一种用于求解诸如</p><script type="math/tex; mode=display">\left\{\begin{aligned}x\equiv a_1&(mod~m_1)\\x\equiv a_2&(mod~m_2)\\......\\x\equiv a_k&(mod~m_k)\end{aligned}\right.</script><p>形式的同余方程的神奇东西,其中 $m_1,m_2, m_3, …, m_k$ 为两两互质的整数,需要求解的是 $x$ 的最小非负整数解.</p><h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>​        设 $M=\prod_{i=0}^{k}m_i,M_i=\frac{M}{m_i},M_it_i=1~(mod~m_i)$.其中 $M$ 表示所有方程组模数的乘积,$M_i$ 表示除了对应方程外其余方程模数的乘积,$t_i$ 则为 $M_i$ 的逆元.</p><p>我们可以构造一个特解 $x_0=\sum_{i=0}^{k}a_iM_it_i$,可以推出方程通解为</p><script type="math/tex; mode=display">x=x_0+k\times M(k\in \mathbb{Z})</script><p>其中最小的正整数解为</p><script type="math/tex; mode=display">x=x_0~mod~M</script><p>使用扩展欧几里得算法求出逆元,进而求出 $x$.</p><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><hr><p>基本形式：</p><script type="math/tex; mode=display">(x+y)^n=\sum_{k=0}^{n}\binom{n}{k}x^ky^{n-k}</script><p>导出结论：</p><script type="math/tex; mode=display">n\in N^+\\\sum_{k=0}^{n}\binom{n}{k}=\sum_{k=0}^{n}\binom{n}{k}\times1^{k}\times1^{n-k}=(1+1)^n=2^n\\\sum_{k=0}^{n}(-1)^k\binom{n}{k}=(1-1)^n=0</script><h3 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h3><hr><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><script type="math/tex; mode=display">g(n) =\sum_{i=1}^{n}\binom{n}{i}f(i)⇔ f(n)=\sum_{i=1}^{n}(-1)^{n-i}\binom{n}{i}g(i)</script><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>先将左式带入右边</p><script type="math/tex; mode=display">f(n)=\sum_{i=1}^{n}(-1)^{n-i}\binom{n}{i}\sum_{k=1}^{i}\binom{i}{k}f(k)</script><p>交换枚举顺序</p><script type="math/tex; mode=display">f(n)=\sum_{k=1}^{n}f(k)\sum_{i=k}^{n}(-1)^{n-i}\binom{n}{i}\binom{i}{k}</script><p>明显有</p><script type="math/tex; mode=display">f(n)=\sum_{k=1}^{n}[k==n]f(k)</script><p>只需要证</p><script type="math/tex; mode=display">\sum_{i=k}^{n}(-1)^{n-i}\binom{n}{i}\binom{i}{k}=[i==k]</script><p>左式展开</p><script type="math/tex; mode=display">\sum_{i=k}^{n}(-1)^{n-i}\frac{n!}{i!(n-i)!}\frac{i!}{k!(i-k)!}\\=\sum_{i=k}^{n}(-1)^{n-i}\frac{n!}{(n-i)!(i-k)!k!}\\=\frac{n!}{k!}\sum_{i=k}^{n}\frac{(-1)^{n-i}}{(n-i)!(i-k)!}</script><p>乘上 $(n-k)!$</p><script type="math/tex; mode=display">\frac{n!}{k!(n-k)!}\sum_{i=k}^{n}(-1)^{n-i}\frac{(n-k)!}{(n-i)!(i-k)!}\\=\binom{n}{k}\sum_{i=k}^{n}(-1)^{n-i}\binom{n-k}{n-i}</script><p>当 $n=k$ 时,上式取值为 $1$,</p><p>当 $n\not = k$ 时,由二项式定理可知上式恒等于 $0$.</p><p>所以上式等价于 $[n==k]$.</p><p>所以原式成立（？）</p><p>参考博客：[二项式反演入门](<a href="https://www.cnblogs.com/lcyfrog/p/11772757.html">https://www.cnblogs.com/lcyfrog/p/11772757.html</a>)</p><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><hr><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>​        设 $S$ 为有穷集,$P_1,P_2,..,P_m$ 是 $m$ 种性质,$A_i$ 是 $S$ 中具有性质 $P_i$ 的元素构成的子集,其中 $i=1,2,…,m$.则 $S$ 中不具有性质 $P_1,P_2,…,P_m$ 的元素个数为</p><script type="math/tex; mode=display">|\overline{A_1}\cap\overline{A_2}\cap...\cap\overline{A_m}|</script><p>​        上式等价于</p><script type="math/tex; mode=display">|S|-\sum_{i=0}^{m}|A_i|+\sum_{1\le i<j\le m}|A_i\cap A_j|-\sum_{1\le i<j<k\le m}|A_i\cap A_j\cap A_k|+...+(-1)^m|A_1\cap A_2\cap ...\cap A_m|</script><h3 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h3><hr><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>​        给定集合 $S$,设 $max(S)$ 为 $S$ 中的最大值,$min(S)$ 为 $S$ 中的最小值,则：</p><script type="math/tex; mode=display">max(S)=\sum_{T\in S}(-1)^{|T|-1}min(T)</script><h4 id="锯个栗子"><a href="#锯个栗子" class="headerlink" title="锯个栗子"></a>锯个栗子</h4><script type="math/tex; mode=display">max(a,b)=min(a)+min(b)-min(a, b)\\max(a,b,c)=min(a)+min(b)+min(c)-min(a,b)-min(a,c)-min(b-c)+min(a,b,c)</script><p>​        当钦定 $a\le b \le c$ 时,上式化简为</p><script type="math/tex; mode=display">max(a,b)=b\\max(a,b,c)=c</script><p>正确性显然.</p><h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h4><p>​        将 $S$ 中的数从大到小排序,第 $i$ 大的数计算次数为 </p><script type="math/tex; mode=display">\sum_{k=0}^{i-1}\binom{i-1}{k}\times(-1)^{k}</script><p>​        上式在 $i\ge 2$ 时恒等于 $0$,在 $i=1$ 的时候等于 $1$.所以求出的即为集合 $S$ 的最大值.</p><h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><h4 id="多重集"><a href="#多重集" class="headerlink" title="多重集"></a>多重集</h4><p>多重集是指包含重复元素的广义集.<br>设多重集 $S={n_1\cdot a_1,n_2\cdot a_2,n_3\cdot a_3,\cdots,n_k\cdot a_k}$,$n=\sum_{i=1}^ka_i$.</p><h5 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h5><p>$S$ 的全排列数为：</p><script type="math/tex; mode=display">\frac{n!}{n_1!n_2!\cdots n_k!}</script><h5 id="限定意义下的组合数"><a href="#限定意义下的组合数" class="headerlink" title="限定意义下的组合数"></a>限定意义下的组合数</h5><p>设整数 $r\le n_i(\forall i\in [1,k])$,从 $S$ 中取出 $r$ 个元素组成一个多重集（不考虑顺序）的方案数为：</p><script type="math/tex; mode=display">\binom{k+r-1}{k-1}</script><p>证明：  因为保证 $r\le n_i(\forall i\in [1, k])$,因此只需要考虑取出所有元素的数量和等于 $r$ 即可,问题可以转化为：从一共 $r + k - 1$ 个数中选择 $r-1$ 个数为 $1$,将所有的数分成 $k$ 组,该问题的方案数为 $\binom{r+k-1}{r-1}$.</p><h5 id="非限定意义下的组合数"><a href="#非限定意义下的组合数" class="headerlink" title="非限定意义下的组合数"></a>非限定意义下的组合数</h5><p>设整数 $r\le n$,从 $S$ 中取出 $r$ 个元素组成一个多重集（不考虑顺序）的方案数为：</p><script type="math/tex; mode=display">\binom{k+r-1}{k-1}-\sum_{k=1}^n\binom{k+r-1-(n_i+1)}{k-1}+\sum_{1\le i<j\le k}\binom{k+r-1-(n_i+1)-(n_j+1)}{k-1}-\cdots+(-1)^k\binom{k+r-1-\sum_{i=1}^{k}(n_i+1)}{k-1}</script><p>证明 &amp; 解释：   对于每一类元素如果没有选取次数限制,则总方案数为 $\binom{k+r-1}{k-1}$,考虑使用枚举超出限制的元素的种类数 $k$,使其选择 $n_i+1$个,剩下的机会随机分给剩下的元素即可,依照容斥原理进行容斥即可算出答案.</p><h2 id="概率和数学期望"><a href="#概率和数学期望" class="headerlink" title="概率和数学期望"></a>概率和数学期望</h2><h3 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>某个事件 $A$ 发生的可能性的大小,称之为 $A$ 的概率,记作 $P(A)$.如果一件事的所有可能情况有 $n$种,事件 $A$ 涵盖了其中的 $m$ 种,那么 $A$ 的概率为 $\frac{n}{m}$.</p><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><p>记随机事件 $A$ 和 $B$.</p><ul><li>若 $A\cap B=\varnothing$,即 $A$ 和 $B$ 无交集,则 $P(A 或 B 发生)=P(A)+P(B)$.</li><li>若 $A\cap B\not =\varnothing$,$P(A 或 B 发生)=P(A)+P(B)-P(A 和 B 同时发生)$.</li><li>若 $A$ 和 $B$ 在互不干扰的事件中,则 $P(A 和 B 同时发生) = P(A)\times P(B)$.</li></ul><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ul><li><p>[LG P5750](<a href="https://www.luogu.com.cn/problem/P5750),直接概率">https://www.luogu.com.cn/problem/P5750),直接概率</a> DP 即可.</p></li><li><p>[BZOJ 5091](Problem/BZOJ5091摘苹果.md),由于每一棵树只能算一次贡献,所以可以将期望转成概率的形式求解.</p></li></ul><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>记随机事件 $A$,若 $A$ 有多种结果,对每一种结果都有一个权值 $w$,每一种结果的概率和权值的乘积之和称作 $A$ 的期望,记作 $E(A)$.</p><script type="math/tex; mode=display">E(A)=\sum_{p\in A}P(p)\times w_p</script><h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h4><p>期望是线性函数,若 $c$ 和 $d$ 为常数,$X$ 和 $Y$ 为随机事件,则有：</p><script type="math/tex; mode=display">E(cX)+E(dY)=cE(x)+dE(Y)</script><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><ul><li>[BZOJ 4832](Problem/BZOJ4832.md)</li><li>[LG P1850](<a href="https://www.luogu.com.cn/problem/P1850">https://www.luogu.com.cn/problem/P1850</a>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>碎碎念</title>
    <link href="/2022/04/04/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2022/04/04/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><h2 id="同余系下最值-DP-中的取值"><a href="#同余系下最值-DP-中的取值" class="headerlink" title="同余系下最值 DP 中的取值"></a>同余系下最值 DP 中的取值</h2><p>如果一道题需要使用 DP 求最值，同时有要求对答案取模输出的话，貌似不能边做 DP 边取模，而是需要使用分数类模拟，算到最优再取模。不然貌似会出现类似于 $\dfrac{1}{2}&gt;1\ (\operatorname{mod}\ 998244353)$ 的情况。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做题笔记</title>
    <link href="/2022/04/04/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/04/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="做题笔记"><a href="#做题笔记" class="headerlink" title="做题笔记"></a>做题笔记</h1><h2 id="CF1628D1-Game-on-Sum-Easy-Version"><a href="#CF1628D1-Game-on-Sum-Easy-Version" class="headerlink" title="CF1628D1 Game on Sum (Easy Version)"></a><a href="https://www.luogu.com.cn/problem/CF1628D1" target="_blank">CF1628D1 Game on Sum (Easy Version)</a></h2><p>先不考虑博弈论，用 DP 的思想考虑一下这道题。</p><p>设 $f(i, j)$ 表示游戏还剩下 $i$ 轮，当前 Bob 已经使用了 $j$ 次加法的 $x$ 值。显然有</p><script type="math/tex; mode=display">f(i, 0) = 0, f(i,i)=i\times c</script><p>如果我们钦定 $c=1$，然后预处理 $f$，询问时直接使用 $f$ 的值乘上 $k$ 即可。</p><p>由于 $f$ 数组是由 Bob 的操作决定的，所以我们是想让 $f$ 尽量小的。<br>转移如下</p><script type="math/tex; mode=display">f(i, j)=min\{f(i-1, j)-p, f(i-1, j-1)+p\}</script><p>其中 $p$ 是 Alice 决定的参数。又因为 Alice 想让 $f$ 的值最大，所以她一定会让 $p$ 满足 $f(i-1, j)-p=f(i-1, j-1)+p$，解得 $p=\frac{f(i-1, j)-f(i-1, j-1)}{2}$，所以 $f(i, j)=\frac{f(i-1, j-1)+f(i-1, j)}{2}$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair <span class="hljs-string">&lt; int, int &gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b) for (auto a : b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">2010</span>)</span>, <span class="hljs-title">Mod</span><span class="hljs-params">(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)</span></span>;<br><span class="hljs-type">int</span> DataNum, N, M, K;<br><span class="hljs-type">int</span> F[kN][kN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">F_Pow</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) a * a % p) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ans = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) ans * a % p;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Inv_2</span><span class="hljs-params">(F_Pow(<span class="hljs-number">2</span>, Mod - <span class="hljs-number">2</span>, Mod))</span></span>;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>) &#123;<br>F[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, F[i][i] = i;<br><span class="hljs-built_in">IR</span>(j, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>) &#123;<br><span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>F[i][j] = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[i - <span class="hljs-number">1</span>][j] + F[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) * Inv_2 % Mod;<br>&#125;<br>&#125;<br>IN &gt;&gt; DataNum; <span class="hljs-keyword">while</span> (DataNum --&gt; <span class="hljs-number">0</span>) &#123;<br>IN &gt;&gt; N &gt;&gt; M &gt;&gt; K, cout &lt;&lt; (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[N][M] * K % Mod &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="P2150-NOI2015-寿司晚宴"><a href="#P2150-NOI2015-寿司晚宴" class="headerlink" title="P2150 [NOI2015] 寿司晚宴"></a><a href="https://www.luogu.com.cn/problem/P2150" target="_blank">P2150 [NOI2015] 寿司晚宴</a></h2><p>题目相当于找出从给定序列中选出两个数集，使得两个数集的质因子集合不交的方案数。</p><p>先考虑 $30$  的部分分，只有 $10$ 个质数，所以可以直接状压 DP。</p><p>设 $dp(i, j, k)$ 表示考虑完前 $i$ 个数，质因子集合分别为 $j$ 和 $k$ 时的方案数（状压），用 $S_i$ 表示第 $i$ 个数的方案数，转移如下</p><script type="math/tex; mode=display">\begin{cases}dp(i,j~|~S_i, k)+=dp(i,j, k)&S_i~\&~k=0\\dp(i,j, k~|~S_i)+=dp(i,j, k)&S_i~\&~j=0\end{cases}</script><p>将第一位用滚动数组省去就得到了一个 $O(2^{20}n)$ 的做法。</p><p>然后考虑 $100$ 分，现在有很多质数不能状压，但是考虑到每一个数只有一个大于 $\sqrt{500}$ 的质因子，所以可以对每一个数都拆分质因数，然后按照大质因子的大小排序，大质因子相同的数当作一组，由于题目限制同一个大质因子不能给两个人，所以考虑分别计算将该大质因子给第一个人和第二个人的方案数，求和再减去都不给的方案数即可。</p><p>具体来讲，设 $dp(i, j, k),~f1(i, j, k),~f2(i, j, k)$，其中 $dp$ 的概念不变，$f1$ 表示将大质因子给第一个人，$f2$ 反之。对于每一段大质因子的数开始时，都将 $dp$ 的值赋给 $f1,~f2$，算完后再合并给 $dp$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> unsigned unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br>  <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>    x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-type">const</span> vector &lt; <span class="hljs-type">unsigned</span> &gt; <span class="hljs-built_in">List</span>(&#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span> &#125;);<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">500</span>)</span></span>;<br><span class="hljs-type">unsigned</span> N, Mod;<br><span class="hljs-type">unsigned</span> DP[kN][kN], F1[kN][kN], F2[kN][kN];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NODE</span> &#123;<br>  <span class="hljs-type">unsigned</span> val, big, S;<br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> val_)</span> </span>&#123;<br>    val = val_, big = S = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt; List.<span class="hljs-built_in">size</span>(); ++i)<br>      <span class="hljs-keyword">if</span> (!(val_ % List[i])) &#123;<br>        S |= (<span class="hljs-number">1</span> &lt;&lt; i); <span class="hljs-keyword">while</span> (!(val_ % List[i])) val_ /= List[i];<br>      &#125;<br>    <span class="hljs-keyword">if</span> (val_ != <span class="hljs-number">1</span>) big = val_;<br>  &#125;<br>  <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> NODE &amp;X) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> big &lt; X.big;<br>  &#125;<br>&#125; A[kN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ADD</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> &amp;y)</span> </span>&#123;<br>  x += y;<br>  x -= x &gt;= Mod ? Mod : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br>  <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>  <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  IN &gt;&gt; N &gt;&gt; Mod;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">2</span>); i &lt;= N; ++i) A[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">init</span>(i);<br>  <span class="hljs-built_in">sort</span>(A + <span class="hljs-number">1</span>, A + <span class="hljs-number">1</span> + N);<br>  DP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt; N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> A[i].big != A[i - <span class="hljs-number">1</span>].big <span class="hljs-keyword">or</span> A[i].big == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">memcpy</span>(F1, DP, <span class="hljs-keyword">sizeof</span> F1), <span class="hljs-built_in">memcpy</span>(F2, DP, <span class="hljs-keyword">sizeof</span> F2);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">255</span>); j &gt;= <span class="hljs-number">0</span>; --j) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">255</span>); k &gt;= <span class="hljs-number">0</span>; --k) &#123;<br>      <span class="hljs-keyword">if</span> (j &amp; k) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> ((A[i].S &amp; j) == <span class="hljs-number">0</span>) <span class="hljs-built_in">ADD</span>(F2[j][k | A[i].S], F2[j][k]);<br>      <span class="hljs-keyword">if</span> ((A[i].S &amp; k) == <span class="hljs-number">0</span>) <span class="hljs-built_in">ADD</span>(F1[j | A[i].S][k], F1[j][k]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == N - <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> A[i].big != A[i + <span class="hljs-number">1</span>].big <span class="hljs-keyword">or</span> A[i].big == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//      for (int j(255); j &gt;= 0; --j) for (int k(255); k &gt;= 0; --k) &#123;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt;= <span class="hljs-number">255</span>; ++j) <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k &lt;= <span class="hljs-number">255</span>; ++k) &#123;<br>        <span class="hljs-keyword">if</span> (j &amp; k) <span class="hljs-keyword">continue</span>;<br>        DP[j][k] = (F1[j][k] + F2[j][k] + Mod - DP[j][k]) % Mod;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt;= <span class="hljs-number">255</span>; ++j) <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k &lt;= <span class="hljs-number">255</span>; ++k) <span class="hljs-built_in">ADD</span>(ans, DP[j][k]);<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Yuno-loves-sqrt-technology-I"><a href="#Yuno-loves-sqrt-technology-I" class="headerlink" title="Yuno loves sqrt technology I"></a><a href="https://www.luogu.com.cn/problem/P5046" target="_blank">Yuno loves sqrt technology I</a></h2><p>简单来说就是求静态区间逆序对，考虑分块。</p><p>设 $F[i][j]$ 表示第 $i$ 块到第 $j$ 块的逆序对数，转移可以这么写</p><script type="math/tex; mode=display">F[i][j]=F[i+1][j]+F[i][j-1]-F[i+1][j-1]+(第~i~块对第~j~块的贡献)</script><p>第 $i$ 块对 $j$ 块的贡献求解的过程在下面给出。</p><p>考虑询问一段区间，逆序对个数就是</p><script type="math/tex; mode=display">\texttt{中间整块+左右散块对中间整块的贡献+左右散块互相的贡献+左散块自身贡献+右散块自身贡献}</script><p>其中第一项可以 $O(1)$ 查，第二项可以再维护 $f[i][j]$ 表示前 $i$ 个数对第 $j$ 块的贡献直接查表，第三项直接提前排序然后归并求解，剩下的可以对每一个数记一个 $Pre[i]$ 和 $Suf[i]$ 表示到 块头/块尾 的逆序对数。</p><p>然后考虑 $f[i][j]$ 如何维护：首先对每一个块内进行排序，然后枚举每一个数，使用类似归并的办法求出这个数对该块的贡献（需要考虑这个数是在该块前还是在该块后），之后再做一遍前缀和就可以了。</p><p>有了 $f$ 数组，我们可以直接在 $f$ 上差分就可以求出一个块对另一个块的贡献了。</p><p>综上，我们就有了一个 $O(N\sqrt{N})$ 的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC target(<span class="hljs-string">&quot;avx&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-type">char</span> buf[(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>) + <span class="hljs-number">100</span>], *p, *e;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getChar</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (p == e) p = buf, e = buf + <span class="hljs-built_in">fread</span>(buf, <span class="hljs-number">1</span>, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>), stdin);<br><span class="hljs-keyword">return</span> p == e ? EOF : *p++;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br><span class="hljs-type">char</span> c, l;<br><span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>; !<span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getChar</span>()) l = c;<br><span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; <span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getChar</span>()) x = x * <span class="hljs-number">10</span> - <span class="hljs-string">&#x27;0&#x27;</span> + c;<br><span class="hljs-keyword">if</span> (l == <span class="hljs-string">&#x27;-&#x27;</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">kB</span><span class="hljs-params">(<span class="hljs-number">400</span>)</span></span>;<br><span class="hljs-type">int</span> N, M, Block, Len;<br><span class="hljs-type">int</span> A[kN], C[kN], D[kN], Pos[kN];<br><span class="hljs-type">int</span> Pre[kN], Suf[kN], L[kB], R[kB], f[kB][kN];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> F[kB][kB];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">Lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<br>  <span class="hljs-type">int</span> val[kN];<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Change</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> delta)</span> </span>&#123; <span class="hljs-keyword">for</span> (; pos &lt;= N; pos += <span class="hljs-built_in">Lowbit</span>(pos)) val[pos] += delta; &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Ask</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-keyword">for</span> (; pos; pos -= <span class="hljs-built_in">Lowbit</span>(pos)) ans += val[pos]; <span class="hljs-keyword">return</span> ans; &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Ask</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123; <span class="hljs-keyword">return</span> L &gt; R ? <span class="hljs-number">0</span> : (L ? <span class="hljs-built_in">Ask</span>(R) - <span class="hljs-built_in">Ask</span>(L - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>); &#125;<br>&#125; Tmp;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PAIR</span> &#123;<br>  <span class="hljs-type">int</span> first, second;<br>  <span class="hljs-built_in">PAIR</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-built_in">PAIR</span>(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second) : <span class="hljs-built_in">first</span>(first), <span class="hljs-built_in">second</span>(second) &#123;&#125;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> PAIR &amp;X) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> first &lt; X.first; &#125;<br>&#125; B[kN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N)</span> </span>&#123;<br>  Block = <span class="hljs-built_in">sqrt</span>(N);<br><span class="hljs-comment">//  Block = 3;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) B[i] = <span class="hljs-built_in">PAIR</span>(A[i], i);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) &#123;<br>    L[i] = R[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R[i] = <span class="hljs-built_in">min</span>(N, L[i] + Block - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">sort</span>(B + L[i], B + R[i] + <span class="hljs-number">1</span>); <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(L[i]); j &lt;= R[i]; ++j) Pos[j] = i, C[j] = B[j].first, D[j] = B[j].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(L[i]); j &lt;= R[i]; ++j) Tmp.<span class="hljs-built_in">Change</span>(A[j], <span class="hljs-number">1</span>), x += Tmp.<span class="hljs-built_in">Ask</span>(N) - Tmp.<span class="hljs-built_in">Ask</span>(A[j]), Pre[j] = x;<br>    F[i][i] = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(L[i]); j &lt;= R[i]; ++j) Suf[j] = x, Tmp.<span class="hljs-built_in">Change</span>(A[j], <span class="hljs-number">-1</span>), x -= Tmp.<span class="hljs-built_in">Ask</span>(A[j] - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (R[i] == N) &#123; Len = i; <span class="hljs-keyword">break</span>; &#125;<br>  &#125; <span class="hljs-built_in">sort</span>(B + <span class="hljs-number">1</span>, B + <span class="hljs-number">1</span> + N);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); j &lt;= Len; ++j) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">k</span>(L[j]); i &lt;= N; ++i) &#123;<br>      <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">ID</span><span class="hljs-params">(B[i].second)</span></span>;<br>      <span class="hljs-keyword">while</span> (k &lt;= R[j] <span class="hljs-keyword">and</span> B[i].first &gt; C[k]) ++k;<br>      <span class="hljs-keyword">if</span> (ID &lt; L[j]) f[j][ID] = k - L[j];<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ID &gt; R[j]) f[j][ID] = R[j] - k - (k &lt;= R[j] <span class="hljs-keyword">and</span> B[i].first == C[k]) + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= Len; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">2</span>); j &lt;= N; ++j) f[i][j] += f[i][j - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">len</span>(<span class="hljs-number">2</span>); len &lt;= Len; ++len) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">l</span>(<span class="hljs-number">1</span>); l + len - <span class="hljs-number">1</span> &lt;= Len; ++l) &#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">r</span><span class="hljs-params">(l + len - <span class="hljs-number">1</span>)</span></span>;<br>    F[l][r] = F[l + <span class="hljs-number">1</span>][r] + F[l][r - <span class="hljs-number">1</span>] - F[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] + f[r][R[l]] - f[r][L[l] - <span class="hljs-number">1</span>];<br>  &#125;<br>&#125;<br><span class="hljs-comment">//inline int Nxd(vector &lt; int &gt; &amp;now, int ans = 0) &#123;</span><br><span class="hljs-comment">//  for (auto v : now) ans += Tmp.Ask(v + 1, N), Tmp.Change(v, 1);</span><br><span class="hljs-comment">//  for (auto v : now) Tmp.Change(v, -1);</span><br><span class="hljs-comment">//  return ans;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Nxd</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b, <span class="hljs-type">int</span> la, <span class="hljs-type">int</span> lb)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ia</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">ib</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (ia &lt;= la <span class="hljs-keyword">and</span> ib &lt;= lb)<br>    <span class="hljs-keyword">if</span> (a[ia] &lt;= b[ib]) ++ia; <span class="hljs-keyword">else</span> ans += la - ia + <span class="hljs-number">1</span>, ++ib;<br><span class="hljs-comment">//  cout &lt;&lt; &quot;a : &quot;; for (int i(1); i &lt;= la; ++i) cout &lt;&lt; a[i] &lt;&lt; &quot; \n&quot;[i == la];</span><br><span class="hljs-comment">//  cout &lt;&lt; &quot;b : &quot;; for (int i(1); i &lt;= lb; ++i) cout &lt;&lt; b[i] &lt;&lt; &quot; \n&quot;[i == lb];</span><br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> x[kB], y[kB], lx, ly;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Ask</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">bl</span><span class="hljs-params">(Pos[l])</span>, <span class="hljs-title">br</span><span class="hljs-params">(Pos[r])</span></span>; <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">//  vector &lt; int &gt; rest;</span><br>  lx = ly = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (bl == br) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(L[bl]); i &lt;= R[bl]; ++i)<br>      <span class="hljs-keyword">if</span> (l &lt;= D[i] <span class="hljs-keyword">and</span> D[i] &lt;= r) y[++ly] = C[i];<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (D[i] &lt; l) x[++lx] = C[i];<br>    ans = Pre[r] - (l == L[bl] ? <span class="hljs-number">0</span> : Pre[l - <span class="hljs-number">1</span>]) - <span class="hljs-built_in">Nxd</span>(x, y, lx, ly);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">//   for (int i(l); i &lt;= R[bl]; ++i) rest.push_back(A[i]);</span><br> <span class="hljs-comment">//   for (int i(L[br]); i &lt;= r; ++i) rest.push_back(A[i]);</span><br> <span class="hljs-comment">//   ans = Nxd(rest) + F[bl + 1][br - 1];</span><br> <span class="hljs-comment">//   for (int i(bl + 1); i &lt; br; ++i) </span><br> <span class="hljs-comment">//     ans += (f[i][R[bl]] - f[i][l - 1]) + (f[i][r] - f[i][L[br] - 1]);</span><br>    ans = F[bl + <span class="hljs-number">1</span>][br - <span class="hljs-number">1</span>] + Pre[r] + Suf[l];<br><span class="hljs-comment">//    cout &lt;&lt; &quot;Suf : &quot; &lt;&lt; Suf[l] &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">//    cout &lt;&lt; &quot;Pre : &quot; &lt;&lt; Pre[r] &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(bl + <span class="hljs-number">1</span>); i &lt; br; ++i) ans += (f[i][R[bl]] - f[i][l - <span class="hljs-number">1</span>]) + (f[i][r] - f[i][L[br] - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(L[bl]); i &lt;= R[bl]; ++i) <span class="hljs-keyword">if</span> (D[i] &gt;= l) x[++lx] = C[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(L[br]); i &lt;= R[br]; ++i) <span class="hljs-keyword">if</span> (D[i] &lt;= r) y[++ly] = C[i];<br><span class="hljs-comment">//    cout &lt;&lt; &quot;Nxd : &quot; &lt;&lt; Nxd(x, y, lx, ly) &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">mid</span><span class="hljs-params">(Nxd(x, y, lx, ly))</span></span>;<br><span class="hljs-comment">//    cout &lt;&lt; &quot;Nxd : &quot; &lt;&lt; mid &lt;&lt; &quot;\n&quot;;</span><br>    ans += mid;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br>  <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>  <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  IN &gt;&gt; N &gt;&gt; M; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) IN &gt;&gt; A[i];<br>  <span class="hljs-built_in">Init</span>(N);<br><span class="hljs-comment">//  return 0;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">last</span>(<span class="hljs-number">0</span>), l, r; i &lt;= M; ++i) &#123;<br>    IN &gt;&gt; l &gt;&gt; r;<br>    l ^= last, r ^= last;<br><span class="hljs-comment">//    if (i &gt;= 100) break;</span><br><span class="hljs-comment">//    if (l &lt; 1 or r &gt; N) break;</span><br>    cout &lt;&lt; (last = <span class="hljs-built_in">Ask</span>(l, r)) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P3674-小清新人渣的本愿"><a href="#P3674-小清新人渣的本愿" class="headerlink" title="P3674 小清新人渣的本愿"></a><a href="https://www.luogu.com.cn/problem/P3674" target="_blank">P3674 小清新人渣的本愿</a></h2><p>由于操作可以离线，所以考虑莫队算法。</p><p>考虑对于所有数字建立一个 bitset，判断两数相差 $x$ 的时候将 bitset 和其左移（或右移）之后的 bitset 按位与，如果结果为 $0$，说明没有两个数差为 $0$，反之就一定有。</p><p>然后考虑第三个乘法询问，可以在莫队的时候维护每一个数是否出现过，然后 $\sqrt{V}$ 的分解质因数即可。</p><p>考虑为什么判断两数相差的方法不能用来考虑两数的和。因为对于两数之差为 $x$ 的时候，如果一个数 $a$ 对应着 $a+x$，那么 $a + 1$ 就对应着 $a + 1 + x$，这符合左移（或右移）的性质。但是对于加法而言，如果 $a$ 对应着 $x - a$，那么 $a + 1$ 就对应着 $x - a - 1$，随着一个数增大，另一个对应的数字再逐渐减小，所以我们考虑建一个顺序相反的 bitset，这样当 $a$ 增大的时候，对应的数再另一个 bitset 上实际上在变小，这就符合左移（或右移）的性质了，可以直接位运算判断。</p><p>代码复杂度为 $O(n\sqrt{n}+\frac{n^2}{w})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br>  <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>    x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-type">unsigned</span> N, M, Block, A[kN], Ans[kN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ASK</span> &#123;<br>  <span class="hljs-type">unsigned</span> Opt, L, R, X, ID;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> ASK &amp;another) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> L / Block == another.L / Block ? R &lt; another.R : L / Block &lt; another.L / Block; &#125;<br>&#125; Q[kN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">M_Que</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">L</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">R</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, Cnt[kN]</span>&#123;<span class="hljs-number">0</span>&#125;;<br>  bitset &lt; kN + 5 &gt; First, Second;<br>  <span class="hljs-keyword">auto</span> Add = [&amp;](<span class="hljs-type">unsigned</span> val) &#123; <span class="hljs-keyword">if</span> (++Cnt[val = A[val]] == <span class="hljs-number">1</span>) First[val] = <span class="hljs-literal">true</span>, Second[kN - val] = <span class="hljs-literal">true</span>; &#125;;<br>  <span class="hljs-keyword">auto</span> Del = [&amp;](<span class="hljs-type">unsigned</span> val) &#123; <span class="hljs-keyword">if</span> (--Cnt[val = A[val]] == <span class="hljs-number">0</span>) First[val] = <span class="hljs-literal">false</span>, Second[kN - val] = <span class="hljs-literal">false</span>; &#125;;<br>  <span class="hljs-built_in">Add</span>(<span class="hljs-number">0</span>); <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= M; ++i) &#123;<br>    <span class="hljs-keyword">while</span> (L &lt; Q[i].L) <span class="hljs-built_in">Del</span>(L++);<br>    <span class="hljs-keyword">while</span> (L &gt; Q[i].L) <span class="hljs-built_in">Add</span>(--L);<br>    <span class="hljs-keyword">while</span> (R &lt; Q[i].R) <span class="hljs-built_in">Add</span>(++R);<br>    <span class="hljs-keyword">while</span> (R &gt; Q[i].R) <span class="hljs-built_in">Del</span>(R--);<br>    <span class="hljs-keyword">if</span> (Q[i].Opt == <span class="hljs-number">1</span>) Ans[Q[i].ID] = ((First &amp; (First &gt;&gt; Q[i].X)) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Q[i].Opt == <span class="hljs-number">2</span>) Ans[Q[i].ID] = ((First &amp; (Second &gt;&gt; (kN - Q[i].X))) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">v</span>(<span class="hljs-number">1</span>); v &lt;= <span class="hljs-built_in">sqrt</span>(Q[i].X); ++v)<br>      <span class="hljs-keyword">if</span> (Q[i].X % v == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> Cnt[v] <span class="hljs-keyword">and</span> Cnt[Q[i].X / v]) &#123; Ans[Q[i].ID] = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>; &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br>  <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>  <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  IN &gt;&gt; N &gt;&gt; M, Block = <span class="hljs-built_in">max</span>(<span class="hljs-number">1.00</span>, N / <span class="hljs-built_in">sqrt</span>(M)); <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) IN &gt;&gt; A[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= M; ++i) IN &gt;&gt; Q[i].Opt &gt;&gt; Q[i].L &gt;&gt; Q[i].R &gt;&gt; Q[i].X, Q[i].ID = i;<br>  <span class="hljs-built_in">sort</span>(Q + <span class="hljs-number">1</span>, Q + <span class="hljs-number">1</span> + N), <span class="hljs-built_in">M_Que</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= M; ++i) cout &lt;&lt; (Ans[i] ? <span class="hljs-string">&quot;hana&quot;</span> : <span class="hljs-string">&quot;bi&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT3898 题解</title>
    <link href="/2022/04/02/AT3898-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/04/02/AT3898-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="AT3898-题解"><a href="#AT3898-题解" class="headerlink" title="AT3898 题解"></a>AT3898 题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个长度为 $n$ 的正整数序列 $A$，再给出一个正整数 $m$,保证 $1\le n,m\le 10^5$。求 $\forall i(1\le i\le m)$ 在序列 $A$ 中有多少数和它互质。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>设当前正在处理 $x$ 的情况，则答案为</p><script type="math/tex; mode=display">\sum_{i=1}^n[gcd(A_i, x)==1]=\sum_{i=1}^n\varepsilon[gcd(A_i, x)]</script><p>根据莫比乌斯反演的结论</p><script type="math/tex; mode=display">\mu*I=\varepsilon</script><p>可以把式子变成</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{e|gcd(A_i, x)}\mu(e)</script><p>交换枚举顺序</p><script type="math/tex; mode=display">\sum_{e|x}\mu(e)\sum_{i=1}^n[e|A_i]</script><p>设 $Cnt(e)$ 表示在 $A$ 中有多少数是 $e$ 的倍数，上式可以变成</p><script type="math/tex; mode=display">\sum_{e|x}\mu(e)Cnt(e)</script><p>设值域为 $V$，$O(n\sqrt{V})$ 的预处理 $Cnt$，再用线性筛求出莫比乌斯函数，然后 $m\sqrt{V}$ 的处理答案即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for (int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">using</span> PII = pair &lt; <span class="hljs-type">int</span>, <span class="hljs-type">int</span> &gt;;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-type">int</span> N, M, Cnt[kN];<br><span class="hljs-type">bool</span> Prime[kN]; <span class="hljs-type">int</span> Mu[kN]; vector &lt; <span class="hljs-type">int</span> &gt; List;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Ols</span><span class="hljs-params">(<span class="hljs-type">int</span> lim)</span> </span>&#123;<br>Mu[<span class="hljs-number">1</span>] = Prime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">2</span>, lim) &#123;<br><span class="hljs-keyword">if</span> (!Prime[i]) List.<span class="hljs-built_in">push_back</span>(i), Mu[i] = <span class="hljs-number">-1</span>;<br><span class="hljs-built_in">IR</span>(j, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>) (List.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i * List[j] &lt;= lim) &#123;<br>Prime[i * List[j]] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (!(i % List[j])) &#123;<br>Mu[i * List[j]] = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> Mu[i * List[j]] = Mu[i] * Mu[List[j]];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-comment">//freopen(&quot;I:/Code/Data/Out.out&quot;, &quot;w&quot;, stdout);</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N &gt;&gt; M;<br><span class="hljs-built_in">Ols</span>(kN - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N, x) &#123;<br>IN &gt;&gt; x; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lim</span><span class="hljs-params">(sqrt(x))</span></span>;<br><span class="hljs-built_in">IR</span>(e, <span class="hljs-number">1</span>, lim) <span class="hljs-keyword">if</span> (x % e == <span class="hljs-number">0</span>) &#123;<br>++Cnt[e];<br><span class="hljs-keyword">if</span> (e != x / e) ++Cnt[x / e];<br>&#125;<br>&#125; <span class="hljs-built_in">IR</span>(x, <span class="hljs-number">1</span>, M) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lim</span><span class="hljs-params">(sqrt(x))</span>, <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-built_in">IR</span>(e, <span class="hljs-number">1</span>, lim) <span class="hljs-keyword">if</span> (x % e == <span class="hljs-number">0</span>) &#123;<br>ans += Mu[e] * Cnt[e];<br><span class="hljs-keyword">if</span> (e != x / e) ans += Mu[x / e] * Cnt[x / e];<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>数学</tag>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络流中的一些概念</title>
    <link href="/2022/03/14/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/03/14/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="网络流中的一些概念"><a href="#网络流中的一些概念" class="headerlink" title="网络流中的一些概念"></a>网络流中的一些概念</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>设无向联通图 $G=(V,E)$</p><ul><li>匹配：在 $G$ 中没有公共端点的边的集合 $M\subseteq E$。</li><li>边覆盖：在 $G$ 中任意顶点都必须是集合 $F$ 中某条边的端点。 $F$ 为 $G$ 的一个边覆盖。</li><li>独立集：在 $G$ 中两两互不连通的点集合 $S\subseteq V$。</li><li>点覆盖：在 $G$ 中任意边都至少有一个顶点在 $S$ 中。$S$ 是 $G$ 的一个点覆盖。</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="最大匹配和最小边覆盖"><a href="#最大匹配和最小边覆盖" class="headerlink" title="最大匹配和最小边覆盖"></a>最大匹配和最小边覆盖</h3><script type="math/tex; mode=display">|M_{max}|+|F_{min}|=|V|</script><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>根据定义，$M_{max}$ 一共覆盖了 $2\times |M_{max}|$ 个点，还剩下 $|V|-2\times |M_{max}|$ 个点尚未被覆盖。</p><p>考虑向 $M$ 中加边，每加入一条边都会使得覆盖点集大小加一（如果加二则不符合最大匹配的定义），所以一共会加入 $|V|-2\times |M_{max}|$ 条边。</p><p>所以 $|F_{min}|=|M_{max}|+2\times |M_{max}|$。\<br>移项得到 $|F_{min}|+|M_{max}|=|V|$。</p><h3 id="最大独立集和最小点覆盖"><a href="#最大独立集和最小点覆盖" class="headerlink" title="最大独立集和最小点覆盖"></a>最大独立集和最小点覆盖</h3><script type="math/tex; mode=display">|S_{max}|+|S_{min}|=|V|</script><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>设一最大独立集为 $S_{max}$，则其补集 $\complement S_{max}$ 一定和 $S_{max}$ 中的任意一点联通。</p><p>根据独立集的定义，$S_{max}$ 中的点一定互不连通，所以 $\complement S_{max}$ 一定包含了任意边的至少一个顶点，所以 $\complement S_{max}$ 是一个顶点覆盖。</p><p>根据补集的定义，$|\complement S_{max}| + |S_{max}|=|V|$。\<br>注意到 $\complement S_{max}=S_{min}$，所以 $|S_{max}|=|S_{min}|=|V|$。</p><h3 id="二分图的特殊性质"><a href="#二分图的特殊性质" class="headerlink" title="二分图的特殊性质"></a>二分图的特殊性质</h3><p>对于二分图而言，有</p><script type="math/tex; mode=display">|M_{max}|=|S_{min}|</script><p>即：最大匹配数等于最小点覆盖数。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>网络流</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-03-09 模拟赛题解</title>
    <link href="/2022/03/09/2022-03-09-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/09/2022-03-09-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-03-09-模拟赛题解"><a href="#2022-03-09-模拟赛题解" class="headerlink" title="2022-03-09 模拟赛题解"></a>2022-03-09 模拟赛题解</h1><h2 id="T1-AGC034D"><a href="#T1-AGC034D" class="headerlink" title="T1 (AGC034D)"></a>T1 (AGC034D)</h2><p>看一眼题面，再看一眼数据范围，网络瘤！但是直接暴力连边数量是 $O(n^2)$ 的，虽然网络流的时间复杂度比较玄学，但是跑 $1e6$ 条边还是有点困难，所以考虑优化连边。</p><p>我们考虑一下曼哈顿距离的定义式</p><script type="math/tex; mode=display">Dis(i, j)=|x_i-x_j|+|y_i-y_j|</script><p>由于有绝对值符号不好计算，所以直接分情况暴力展开</p><script type="math/tex; mode=display">Dis(i, j)=\begin{cases}(x_i-x_j)+(y_i-y_j)=(x_i+y_i)+(-x_j-y_j)\\(x_i-x_j)+(-y_i+y_j)=(x_i-y_i)+(-x_j+y_j)\\(-x_i+x_j)+(y_i-y_j)=(-x_i+y_i)+(x_j-y_j)\\(-x_i+x_j)+(-y_i+y_j)=(-x_i-y_i)+(x_j+y_j)\\\end{cases}</script><p>考虑额外新建 $4$ 个点，分别表示四种情况。从源点向黑点连边，每一个黑点再向额外的新建点按照上述讨论连边。</p><p>但是这样还有一个问题，因为可能会出现最大流流错位的情况，仔细考虑一下就会发现这样是不会出现这种情况的，原因是根据绝对值的性质，如果整体取了负号结果一定会变小，又因为费用流的性质所以能够保证满足题目性质。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">6e6</span> + <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-type">int</span> N;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NET</span> &#123;<br><span class="hljs-type">int</span> size, s, t;<br><span class="hljs-type">int</span> tot, head[kN], next[kN], ver[kN], edge[kN], money[kN];<br><span class="hljs-type">int</span> dis[kN], vis[kN], now[kN], use;<br><span class="hljs-built_in">NET</span>() &#123; tot = <span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>ver[++tot] = y, next[tot] = head[x], head[x] = tot, edge[tot] = z, money[tot] = w;<br>ver[++tot] = x, next[tot] = head[y], head[y] = tot, edge[tot] = <span class="hljs-number">0</span>, money[tot] = -w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span> </span>&#123;<br>queue &lt; <span class="hljs-type">int</span> &gt; Q;<br><span class="hljs-built_in">FL</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">int</span>) * (size + <span class="hljs-number">5</span>)), <span class="hljs-built_in">FL</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">int</span>)  * (size + <span class="hljs-number">5</span>));<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tmp</span><span class="hljs-params">(dis[<span class="hljs-number">0</span>])</span></span>;<br>Q.<span class="hljs-built_in">push</span>(s), dis[s] = <span class="hljs-number">0</span>, vis[s] = <span class="hljs-number">1</span>, now[s] = head[s];<br><span class="hljs-comment">//TE();</span><br><span class="hljs-keyword">while</span> (Q.<span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(Q.front())</span></span>; Q.<span class="hljs-built_in">pop</span>(), vis[x] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">ER</span>(e, x, y) &#123;<br><span class="hljs-keyword">if</span> (edge[e] <span class="hljs-keyword">and</span> dis[y] &gt; dis[x] + money[e]) &#123;<br>dis[y] = dis[x] + money[e], now[y] = head[y];<br><span class="hljs-keyword">if</span> (!vis[y]) &#123;<br>vis[y] = <span class="hljs-number">1</span>;<br>Q.<span class="hljs-built_in">push</span>(y);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//TE();</span><br><span class="hljs-built_in">FL</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) * (size + <span class="hljs-number">5</span>)); <span class="hljs-keyword">return</span> dis[t] != tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">Dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> flow)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == t) <span class="hljs-keyword">return</span> flow;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rest</span><span class="hljs-params">(flow)</span></span>;<br>vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;<span class="hljs-built_in">e</span>(now[x]); e; e = next[e]) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">y</span><span class="hljs-params">(ver[e])</span></span>;<br><span class="hljs-keyword">if</span> (edge[e] <span class="hljs-keyword">and</span> dis[y] == dis[x] + money[e] <span class="hljs-keyword">and</span> !vis[y]) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">k</span><span class="hljs-params">(Dinic(y, min(rest, edge[e])))</span></span>;<br>rest -= k, edge[e] -= k, edge[e ^ <span class="hljs-number">1</span>] += k, use += k * money[e];<br><span class="hljs-keyword">if</span> (!k) dis[y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!rest) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>vis[x] = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> flow - rest;<br>&#125;<br>&#125; Gp;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N;<br>Gp.size = (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">6</span>;<br>Gp.s = (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">5</span>, Gp.t = (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">6</span>;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N, x, y, c)  &#123;<br>IN &gt;&gt; x &gt;&gt; y &gt;&gt; c;<br>Gp.<span class="hljs-built_in">Ins</span>(Gp.s, i, c, <span class="hljs-number">0</span>);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, INF, x + y);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>, INF, x - y);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">3</span>, INF, -x + y);<br>Gp.<span class="hljs-built_in">Ins</span>(i, (N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>, INF, -x - y);<br>&#125;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N, x, y, c)  &#123;<br>IN &gt;&gt; x &gt;&gt; y &gt;&gt; c;<br>Gp.<span class="hljs-built_in">Ins</span>(i + N, Gp.t, c, <span class="hljs-number">0</span>);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, i + N, INF, -x - y);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>, i + N, INF, -x + y);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">3</span>, i + N, INF, x - y);<br>Gp.<span class="hljs-built_in">Ins</span>((N &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>, i + N, INF, x + y);<br>&#125;<br><span class="hljs-keyword">while</span> (Gp.<span class="hljs-built_in">SPFA</span>()) Gp.<span class="hljs-built_in">Dinic</span>(Gp.s, INF);<br>cout &lt;&lt; -Gp.use &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2-ARC073C"><a href="#T2-ARC073C" class="headerlink" title="T2 (ARC073C)"></a>T2 (ARC073C)</h2><p>下面对于每一组的两个球 $x,~y$，默认 $x&lt;y$。</p><p>如果我们已经有了一种最优方案，那么将这种方案的红黑互换对于答案是没有影响的。</p><p>所以我们可以钦定最大值被染成红色，然后分情况讨论。</p><p>第一种情况，最小值是黑色。这种情况下我们就贪心地将 $x$ 都给黑色，$y$ 都给红色。</p><p>第二种情况，最小值是红色。这时红球的答案已经知道了，把二元组按照 $x$ 从小到大排序，然后钦定 $[2,n]$ 里的某一个 $x$ 为黑色的最小值，然后这个二元组之后的都选 $x$（因为 $x<y$，而我们要尽量让最大值和最小值的差值小，所以要尽可能选择小的数），之前的都选 $y$（因为之前选了 $x$ 那当前这个就不是最小值了），此时黑色的答案就是<b> $min$（这之前 $y$ 的最小值，x） - $max$（这之前 $y$ 的最大值，最后的 $x$）&lt;/b&gt;，和红色的乘起来就做完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair <span class="hljs-string">&lt; int, int &gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for (int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0ull</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-type">int</span> N, Ans;<br>PII A[kN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Bmax</span><span class="hljs-params">(-INF)</span>, <span class="hljs-title">Bmin</span><span class="hljs-params">(INF)</span>, <span class="hljs-title">Rmax</span><span class="hljs-params">(-INF)</span>, <span class="hljs-title">Rmin</span><span class="hljs-params">(INF)</span></span>;<br><span class="hljs-type">int</span> PreMAX[kN], PreMIN[kN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Cmp</span><span class="hljs-params">(PII A, PII B)</span> </span>&#123;<br><span class="hljs-keyword">return</span> A.first &lt; B.first;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N, x, y) &#123;<br>IN &gt;&gt; x &gt;&gt; y; <span class="hljs-keyword">if</span> (x &gt; y) <span class="hljs-built_in">swap</span>(x, y);<br>Bmax = <span class="hljs-built_in">max</span>(Bmax, x), Bmin = <span class="hljs-built_in">min</span>(Bmin, x);<br>Rmax = <span class="hljs-built_in">max</span>(Rmax, y), Rmin = <span class="hljs-built_in">min</span>(Rmin, y); A[i] = &#123;x, y&#125;;<br>&#125;<br>Ans = (Bmax - Bmin) * (Rmax - Rmin); PreMAX[<span class="hljs-number">0</span>] = -INF, PreMIN[<span class="hljs-number">0</span>] = INF;<br><span class="hljs-built_in">sort</span>(A + <span class="hljs-number">1</span>, A + <span class="hljs-number">1</span> + N, Cmp); Rmin = A[<span class="hljs-number">1</span>].first;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) PreMAX[i] = <span class="hljs-built_in">max</span>(PreMAX[i - <span class="hljs-number">1</span>], A[i].second), PreMIN[i] = <span class="hljs-built_in">min</span>(PreMIN[i - <span class="hljs-number">1</span>], A[i].second);<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">2</span>, N) &#123;<br>Ans = <span class="hljs-built_in">min</span>(Ans, (Rmax - Rmin) * (<span class="hljs-built_in">max</span>(PreMAX[i - <span class="hljs-number">1</span>], A[N].first) - <span class="hljs-built_in">min</span>(PreMIN[i - <span class="hljs-number">1</span>], A[i].first)));<br>&#125;<br>cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3-AGC028D"><a href="#T3-AGC028D" class="headerlink" title="T3 (AGC028D)"></a>T3 (AGC028D)</h2><p>直接考虑区间 DP。</p><p>设 $n=2N$。<br>考虑 $f(i, j)$ 表示 $i$ 和 $j$ 两个点在同一个连通块的方案数，如果该连通块有连出去的边，则一定有 $f(i, j)=0$，该连通块的贡献就是 $f(i, j)$ 乘上其他点随便连边的方案数</p><p>对于后面的东西，设 $g(x)$ 表示 $x$ 个点两两连边的方案数，$g$ 有以下转移</p><script type="math/tex; mode=display">g(x)=\begin{cases}0&x\mod 2 = 1\\g(x - 2)\times(x-1)&x\mod 2=0\end{cases}</script><p>下面考虑 $f$ 的转移，可以容斥一下（$Sum(l, r)$ 表示 $[l,r]$ 里能自由连边的点）</p><script type="math/tex; mode=display">f(l, r)=\begin{cases}0&(r-l+1)\mod 2=1\\g(Sum(l, r))-\sum_{k=l}^{r-1}f(l, k)\times g(Sum(k+1, r))&else\end{cases}</script><p>然后答案就是</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i+2}^nf(i, j)\times g(n - 2 * K-Sum(i, j))</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair <span class="hljs-string">&lt; int, int &gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for (int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for (int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">605</span>)</span>, <span class="hljs-title">Mod</span><span class="hljs-params">(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)</span></span>;<br><span class="hljs-type">int</span> N, K, Buc[kN];<br><span class="hljs-type">int</span> F[kN][kN], G[kN];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N &gt;&gt; K; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K, x, y) IN &gt;&gt; x &gt;&gt; y, Buc[x] = y, Buc[y] = x;<br>N &lt;&lt;= <span class="hljs-number">1</span>;<br>G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i += <span class="hljs-number">2</span>) G[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) G[i - <span class="hljs-number">2</span>] * (i - <span class="hljs-number">1</span>) % Mod;<br><span class="hljs-comment">//IR(i, 1, N) cout &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; G[i] &lt;&lt; &quot;\n&quot;;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">Len</span>(<span class="hljs-number">2</span>); Len &lt;= N; Len += <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">IR</span>(L, <span class="hljs-number">1</span>, N - Len + <span class="hljs-number">1</span>) &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">R</span><span class="hljs-params">(L + Len - <span class="hljs-number">1</span>)</span>, <span class="hljs-title">C</span><span class="hljs-params">(Len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-built_in">IR</span>(k, L, R) <span class="hljs-keyword">if</span> (Buc[k] <span class="hljs-built_in">and</span> (--C, Buc[k] &lt; L <span class="hljs-keyword">or</span> Buc[k] &gt; R)) &#123; flag = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>; &#125;<br><span class="hljs-comment">//cout &lt;&lt; L &lt;&lt; &quot; -&gt; &quot; &lt;&lt; R &lt;&lt; &quot; : &quot; &lt;&lt; (flag ? &quot;NO &quot; : &quot;OK&quot;) &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">continue</span>;<br>F[L][R] = G[C];<br><span class="hljs-comment">//IR(k, L, R - 1, D(0)) &#123;</span><br><span class="hljs-built_in">OR</span>(k, R, L + <span class="hljs-number">1</span>, <span class="hljs-built_in">D</span>(<span class="hljs-number">0</span>)) &#123;<br>D += !Buc[k];<br>F[L][R] = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[L][R] - (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[L][k - <span class="hljs-number">1</span>] * G[D] % Mod + Mod) % Mod;<br>&#125;<br>Ans = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) Ans + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) F[L][R] * G[N - (K &lt;&lt; <span class="hljs-number">1</span>) - C] % Mod) % Mod;<br>&#125;<br>&#125;<br><br>cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>模拟赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟赛</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-03-08 模拟赛题解</title>
    <link href="/2022/03/08/2022-03-08-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/08/2022-03-08-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-03-08-模拟赛题解"><a href="#2022-03-08-模拟赛题解" class="headerlink" title="2022-03-08 模拟赛题解"></a>2022-03-08 模拟赛题解</h1><p><a href = 题面.zip>题面</a></p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>考虑不可能给排名更低的队伍送气球，且如果排名更高的队伍送气球一定会送到炸。</p><p>所以考虑先对其他队伍按照气球数从大到小排序，然后建一个小根堆，按照送气球到炸的数量重载小于号，将排名高于我们的队伍都放到堆里，每次取出堆顶处理一下就做完了。</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>考虑对于每一条边分别处理贡献，因此我们只需要知道每一条边走了多少次，维护两个树上差分数组即可。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>考虑把直径拎出来，如果拆分出来的边不在直径上，对答案的贡献一定还是直径。</p><p>如果拆分的边在直径上，就会分成左右两部分。单独考虑左边的情况（右边同理），根据直径的定义，左边的新直径的左端点一定是原先直径的左端点（否则与直径是最长的路径矛盾），然后对于每一个直径上的点记录自己到子树内的最长链长度，接着求出左端点到这个点的路径长度和自己的最长链长度求和，然后更新最大值即可。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>模拟赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟赛</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分入门</title>
    <link href="/2022/03/04/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%85%A5%E9%97%A8/"/>
    <url>/2022/03/04/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="微积分入门"><a href="#微积分入门" class="headerlink" title="微积分入门"></a>微积分入门</h1><p>详见 3blue1brown 的微积分视频。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>微积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论入门</title>
    <link href="/2022/03/01/%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2022/03/01/%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="博弈论入门"><a href="#博弈论入门" class="headerlink" title="博弈论入门"></a>博弈论入门</h1><h2 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h2><p>公平组合游戏是指满足以下性质的游戏：</p><ul><li>游戏有且仅有两人，轮流操作。</li><li>双方在任意时刻的决策集合仅和时刻的状态有关，和决策者无关。</li></ul><h2 id="Nim-游戏"><a href="#Nim-游戏" class="headerlink" title="Nim 游戏"></a>Nim 游戏</h2><p>有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个。两名玩家轮流取走某一堆的若干个石子，可以取完但是不能不取，最后不能取石子的玩家判负，问先手是否有必胜策略。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>若 $a_1\oplus a_2\oplus \cdots\oplus a_n\not ={0}$ 先手必胜，否则先手必败。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>若存在一个局面的异或和不为 $0$，设当前异或和二进制表示下最高位的位数为 $k$，根据异或定义，一定有奇数个数在二进制的 $k$ 位上值为 $1$，所以一定存在一个 $a_i&gt;2^k$，可以从第 $i$ 堆里拿出 $a_i-2^k$ 个石子使得异或和为 $0$。</p><p>若当前局面异或和为 $0$，则一定不存在一种方案使得取完石子后异或和仍未零。可以使用反证法。设</p><script type="math/tex; mode=display">a_1\oplus\cdots\oplus a_i\oplus\cdots\oplus a_n = 0</script><p>若命题不成立，则可以在 $a_i$ 中取 $k$ 个石子使得异或和仍未零，则会有</p><script type="math/tex; mode=display">a_1\oplus\cdots\oplus (a_i - k)\oplus\cdots\oplus a_n = a_1\oplus\cdots\oplus a_i\oplus\cdots\oplus a_n = 0</script><p>根据异或的性质可以把无关项消掉，得到</p><script type="math/tex; mode=display">a_i=a_i-k\Rightarrow k=0</script><p>这与不取石子的规则相违背，故原命题成立。</p><h2 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h2><p>考虑到公平组合游戏千差万别，对于每一种游戏都想出一个类似于 Nim 游戏的精巧证明并不容易，所以我们引入了 SG 函数。</p><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>首先举一个 Nim 游戏的例子。有四堆石子 $1,2,3,7$。考虑将母问题拆分成四个子问题。</p><p>对于第一堆石子，只能取 $1$ 个把它变成 $0$ 从而使得后手必败，我们称这种状态为 <b>一级胜态</b>，第二堆石子只能变成 $0,1$，称其为 <b>二级胜态</b>，以此类推可以得到 $n$ 个石子为 <b>$n$ 级胜态</b>。特别的，将 <b>$0$</b> 称作 <b>终态</b>，终态不可继续操作。</p><p>然后定义一个胜态为 $n$ 级胜态，当其可以变为 $[1,n-1]$ 中的所有等级胜态时。同时定义 $\operatorname{mex}$ 函数为找出一个非负整数集合里<b>未出现过</b>的<b>最小</b>非负整数值。</p><p>然后我们考虑给这个类似于函数的<b>胜态级别</b>取一个高端大气的名字…就叫 $SG$ 函数吧！</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><!-- 对于任何一个母问题，都可以将其转化为两部分子问题。设母问题为 $X$，其可以分为 $A$ 和 $B$ 两个子问题。- 如果 $A$ 和 $B$ 均为先手必败的局面，此时无论先手如何操作都只能将局面变为一个先手必胜一个先手必败的局面（类比 Nim 游戏）。此时后手只需将必胜局面变为必败局面就可以将问题变回原样，直至 $A$ 和 $B$ 都为终态为止。所以此时先手必败。- 如果 $A$ 为先手必败，$B$ 为先手必胜，此时先手只需将 $B$ 变成先手必败状态，即可让后手进入第一种情况，所以此时先手必胜。- 如果 $A$ 和 $B$ 均为先手必胜，先手一定不能将局面转化为第二种情况，否则必败。所以在这种情况时，我们需要知道关于 $A$ 和 $B$ 更加详细的信息才能得知结果。 --><p>首先根据定义我们有</p><script type="math/tex; mode=display">SG(A)=\operatorname{mex}(SG(B)|A\rightarrow B)</script><p>然后定义一种运算 $@$ 表示将两个子问题合在一起，由基本事实可以得到：</p><ul><li>$SG(A@B@C)=SG(A@(B@C))$</li><li>$SG(A @ 0)=SG(A)$，因为一个空的子问题对答案没有影响。</li><li>$SG(A@A)=0$，因为两个相同的子问题无论先手如何操作后手都可以复制，所以先手必败。</li></ul><p>根据观察可以发现 $@$ 这种运算和 $\oplus$ 很相似，接下来我们将通过严谨的证明来说明 $@$ 和 $\oplus$ 是等价的。</p><p>由定义可知</p><script type="math/tex; mode=display">SG(A@B)=\operatorname{mex}(\{SG(C)|A\rightarrow C\}\{SG(D)|B\rightarrow D\})</script><p>如果要证明 $@\Leftrightarrow\oplus$，只需证明</p><ol><li>$SG(A)\oplus SG(B)\not\in\{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}$</li><li>$\forall E &lt; SA(A)\oplus SG(B)$，都有 $E\in \{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}$。</li></ol><p>对于第一个式子：</p><script type="math/tex; mode=display">\begin{aligned}&\because A\rightarrow C,~B\rightarrow D\\&\therefore SG(A)\not ={SG(B)},~SG(B)\not ={SG(D)}\\&\therefore SG(A)\oplus SG(B)\not\in\{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}\end{aligned}</script><p>对于第二个式子：</p><p>设 $F=SG(A)\oplus SG(B)\oplus E$，将 $F$ 和组成它的三部分中的一个异或，一定会使得结果变小（因为 $F$ 最高位上的 $1$ 一定来自其一），而这个数一定不是 $E$，因为 $F\oplus E=SA(A)\oplus SA(B)&gt;E$（由 $E$ 的定义可知）。</p><p>不妨设 $F\oplus SG(A)&lt;SG(A)$，此时由 $SG(B)\oplus E&lt;SG(A)$，再由 $SG$ 函数额定义可以得到，一定有一个 $A$ 的后继状态 $C$ 使得 $SG(C)=SG(B)\oplus E$，从而有 $E=SB(C)\oplus SG(B)$。</p><p>然后我们就证明了 $\forall E &lt; SA(A)\oplus SG(B)$，都有 $E\in \{\{SG(A)\oplus SG(C)|B\rightarrow C\}\cup\{SG(D)\oplus SG(B)|A\rightarrow D\}\}$。</p><p>总结一下，我们就得到了 $SG$ 函数的两条高明性质：</p><ul><li>$SG(A)=\operatorname{mex}(SG(B)|A\rightarrow B)$</li><li>$SG(A@B)=SG(A)\oplus SG(B)$</li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="GZOI2017-取石子游戏"><a href="#GZOI2017-取石子游戏" class="headerlink" title="[GZOI2017] 取石子游戏"></a>[GZOI2017] 取石子游戏</h3><p>考虑 Nim 游戏的获胜条件，先手必胜当前仅当开始局面异或和为 $0$，为了让阴险的 Alice 不能获胜，有以下两种办法：</p><ul><li>开局异或和为 $0$。</li><li>开局异或和不为 $0$，但是指定的一堆石子数量小于其他石子的异或和。</li></ul><p>第一种情况可以认为是指定的一堆石子必须等于其他石子的异或和，所以我们的任务就是：从 $n$ 堆石子中选择任意堆，从选择的石子堆里面选出一堆，使其数量小于等于选择的其他石子的异或和。</p><p>考虑钦定 Alice 选哪一堆，然后用动态规划求出其余石子异或和大于等于选定石子个数的方案数即可。</p><p>设钦定 Alice 选择第 $i$ 堆石子， $f_{j, k}$ 表示前 $j$ 堆里，异或和等于 $k$ 的方案数，容易得到转移方程：</p><script type="math/tex; mode=display">f_{j,k}=\begin{cases}f_{j-1,k}&i=j\\f_{j-1,k}+f_{j-1,k\oplus A_j}&i\not ={j}\end{cases}</script><p>分两种情况的原因是钦定的石子堆是不能用来转移的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-comment">//#define int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">222</span>)</span>, <span class="hljs-title">kV</span><span class="hljs-params">(<span class="hljs-number">257</span>)</span>, <span class="hljs-title">Mod</span><span class="hljs-params">(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)</span></span>;<br><span class="hljs-type">int</span> N, A[kN], Ans;<br><span class="hljs-type">int</span> F[kN][kV];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  IN &gt;&gt; N; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) IN &gt;&gt; A[i];<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) &#123;<br><span class="hljs-built_in">FL</span>(F, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> F);<br>F[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br><span class="hljs-built_in">IR</span>(j, <span class="hljs-number">1</span>, N) &#123;<br><span class="hljs-built_in">IR</span>(k, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>) &#123;<br><span class="hljs-keyword">if</span> (i == j) F[j][k] = F[j - <span class="hljs-number">1</span>][k];<br><span class="hljs-keyword">else</span> F[j][k] = (F[j - <span class="hljs-number">1</span>][k] + F[j - <span class="hljs-number">1</span>][k ^ A[j]]) % Mod;<br>&#125;<br>&#125;<br><span class="hljs-built_in">IR</span>(j, A[i], <span class="hljs-number">255</span>) Ans = (Ans + F[N][j]) % Mod;<br>&#125;<br>cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-03-01 模拟赛题解</title>
    <link href="/2022/03/01/2022-03-01-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/01/2022-03-01-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-03-01-模拟赛题解"><a href="#2022-03-01-模拟赛题解" class="headerlink" title="2022-03-01 模拟赛题解"></a>2022-03-01 模拟赛题解</h1><p><a href = 题面.zip>题面</a></p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>输入/输出优化模板（虽然 cin + string + deque） 的常数都过了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(unsigned int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(unsigned int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(unsigned int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-type">char</span> buf[(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>) + <span class="hljs-number">100</span>], *p, *e;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getChar</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (p == e) p = buf, e = buf + <span class="hljs-built_in">fread</span>(buf, <span class="hljs-number">1</span>, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>), stdin);<br><span class="hljs-keyword">return</span> p == e ? EOF : *p++;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br><span class="hljs-type">char</span> c, l;<br><span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>; !<span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getChar</span>()) l = c;<br><span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; <span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getChar</span>()) x = x * <span class="hljs-number">10</span> - <span class="hljs-string">&#x27;0&#x27;</span> + c;<br><span class="hljs-keyword">if</span> (l == <span class="hljs-string">&#x27;-&#x27;</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (T x) &#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">10</span>) *<span class="hljs-keyword">this</span> &lt;&lt; x / <span class="hljs-number">10</span>;<br><span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kN = <span class="hljs-number">1e5</span> + <span class="hljs-number">15</span>, kM = <span class="hljs-number">1e7</span> + <span class="hljs-number">17</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> N, P;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> A[kN];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> Ans[kM];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Top;<br>deque &lt; <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> &gt; Q;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Opt[kM];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) IN &gt;&gt; A[i];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; IN &gt;&gt; P;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, P) &#123;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Opt</span><span class="hljs-params">(IN.getChar())</span></span>;<br><span class="hljs-keyword">while</span> (Opt &lt; <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> Opt &gt; <span class="hljs-string">&#x27;4&#x27;</span>) IN.<span class="hljs-built_in">getChar</span>();<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">op</span><span class="hljs-params">(Opt - <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>Q.<span class="hljs-built_in">push_back</span>(A[cnt]);<br><span class="hljs-keyword">if</span> (++cnt == N + <span class="hljs-number">1</span>) cnt = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>Ans[++Top] = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop_front</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>Ans[++Top] = Q.<span class="hljs-built_in">back</span>(); Q.<span class="hljs-built_in">pop_back</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">IR</span>(j, <span class="hljs-number">1</span>, Top) &#123;<br><span class="hljs-keyword">if</span> (flag <span class="hljs-keyword">and</span> Ans[j] != <span class="hljs-number">0</span>) flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>) IN &lt;&lt; Ans[j];<br>&#125;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>Top = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>状态压缩 DP，但是我不会 awa。</p><p>设 $f(i,j)$ 表示最后一个任务点为 $i$，已经做完的任务集合为 $j$ 时的答案， $g(i, j)$ 表示达到 $f(i, j)$ 答案时的最短时间。</p><p>枚举下一个走到的任务点转移即可（要注意当 $f$ 变大时，$g$ 不能取较小值而应该直接复制）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">222</span>)</span>, <span class="hljs-title">kK</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-type">int</span> N, M, K;<br><span class="hljs-type">int</span> Mp[kN][kN];<br><span class="hljs-type">int</span> F[<span class="hljs-number">20</span>][kK], G[<span class="hljs-number">20</span>][kK];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NODE</span> &#123;<br><span class="hljs-type">int</span> u, l, r, t, c;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">In</span><span class="hljs-params">()</span> </span>&#123; IN &gt;&gt; u &gt;&gt; l &gt;&gt; r &gt;&gt; t &gt;&gt; c; &#125;<br>&#125; D[kN];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N &gt;&gt; M; <span class="hljs-built_in">FL</span>(Mp, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> Mp); <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) Mp[i][i] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, M, x, y, z) IN &gt;&gt; x &gt;&gt; y &gt;&gt; z,<br>Mp[x][y] = <span class="hljs-built_in">min</span>(Mp[x][y], z), Mp[y][x] = <span class="hljs-built_in">min</span>(Mp[y][x], z);<br>IN &gt;&gt; K; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K) D[i].<span class="hljs-built_in">In</span>();<br><span class="hljs-built_in">IR</span>(k, <span class="hljs-number">1</span>, N) <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, N) <span class="hljs-built_in">IR</span>(j, <span class="hljs-number">1</span>, N)<br>Mp[i][j] = <span class="hljs-built_in">min</span>(Mp[i][j], Mp[i][k] + Mp[k][j]);<br><span class="hljs-comment">//IR(i, 1, N) IR(j, 1, N) cout &lt;&lt; i &lt;&lt; &quot; -&gt; &quot; &lt;&lt; j &lt;&lt; &quot; : &quot; &lt;&lt; Mp[i][j] &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-built_in">FL</span>(F, <span class="hljs-number">0xcf</span>, <span class="hljs-keyword">sizeof</span> F), <span class="hljs-built_in">FL</span>(G, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> G);<br>F[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = G[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">IR</span>(S, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; K) - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K) &#123;<br><span class="hljs-built_in">IR</span>(k, <span class="hljs-number">1</span>, K) &#123;<br><span class="hljs-keyword">if</span> ((S &gt;&gt; (k - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">To</span><span class="hljs-params">(D[k].u)</span>, <span class="hljs-title">Fr</span><span class="hljs-params">(D[i].u)</span></span>;<br><span class="hljs-keyword">if</span> (G[i][S] + Mp[Fr][To] &gt; D[k].r) <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//RE();</span><br><span class="hljs-keyword">if</span> (F[i][S] + D[k].c &gt; F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))]) &#123;<br>F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))] = <span class="hljs-built_in">max</span>(<br>F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))],<br>F[i][S] + D[k].c<br>);<br>G[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))] = <span class="hljs-built_in">max</span>(D[k].l, G[i][S] + Mp[Fr][To]) + D[k].t;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (F[i][S] + D[k].c == F[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))]) &#123;<br>G[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))] = <span class="hljs-built_in">min</span>(<br>G[k][S | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))],<br><span class="hljs-built_in">max</span>(D[k].l, G[i][S] + Mp[Fr][To]) + D[k].t<br>);<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(-INF)</span></span>;<br><span class="hljs-built_in">IR</span>(S, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; K) - <span class="hljs-number">1</span>) <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">1</span>, K) ans = <span class="hljs-built_in">max</span>(ans, F[i][S]);<br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">TE</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>还不会…</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>模拟赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟赛</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式笔记</title>
    <link href="/2022/02/28/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/28/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="多项式笔记"><a href="#多项式笔记" class="headerlink" title="多项式笔记"></a>多项式笔记</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义 $n$ 次多项式 $f(x)=\sum_{i=0}^na_ix^i$，称其最高项系数的次数为该多项式的度，记作 $\deg f$。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>定义如下多项式</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^na_ix^i\\g(x)=\sum_{i=0}^nb_ix^i\\</script><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><script type="math/tex; mode=display">f(x)+f(y)=\sum_{i=0}^n(a_i+b_i)x^i</script><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><script type="math/tex; mode=display">f(x)-f(y)=\sum_{i=0}^n(a_i-b_i)x^i</script><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><script type="math/tex; mode=display">f(x)\cdot g(x)=\sum_{i=0}^n\sum_{j=0}^na_ib_jx^{i+j}</script><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>若存在唯一的 $Q(x),~R(x)$ 满足</p><script type="math/tex; mode=display">f(x)=Q(x)g(x)+R(x)\\\deg R < \deg g</script><p>若 $\deg f &gt; \deg g$，此时 $\deg Q=\deg  f-\deg g$，否则有 $Q(x)=0$。称 $Q(x)$ 为 $f(x)$ 除以 $g(x)$ 的商， $R(x)$ 为 $f(x)$ 除以 $g(x)$ 的余数，也可以记作</p><script type="math/tex; mode=display">f(x)\equiv R(x)(mod~g(x))</script><h2 id="朗格拉日插值"><a href="#朗格拉日插值" class="headerlink" title="朗格拉日插值"></a>朗格拉日插值</h2><p>由初中数学可以知道，如果给定平面上的 $n$ 个点，则可以唯一确定一个 $n-1$ 次的多项式（如两点确定一个一次多项式，三点确定一个二次多项式），如果要求出该多项式每一项的系数，可以使用高斯消元法， 时间复杂度为 $O(n^3)$，时间复杂度过高。</p><p>朗格拉日插值法使用构造的方式在 $O(n^2)$ 求解多项式系数。</p><p>首先构造 $n$ 个函数，其中第 $i$ 个函数 $f_i(x)$ 满足<br>$<br>f_i(x)=\begin{cases}<br>0&amp; (x\not=x_i)\\<br>y_i&amp; (x= x_i)<br>\end{cases}<br>$  </p><p>最后要求的多项式 $f(x)=\sum_{i=1}^nf_i(x)$。<br>可以设</p><script type="math/tex; mode=display">f_i(x)=a\cdot\prod_{j\not=i}(x-x_j)</script><p>将 $f_i(x_i)=y_i$ 代入得到</p><script type="math/tex; mode=display">a=\frac{y_i}{\prod_{j\not ={i}}}(x_i-x_j)</script><p>所以</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^ny_i\prod_{j\not ={i}}\frac{x-x_j}{x_i-x_j}</script><h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><p>多项式的加法和减法按照定义都可以在 $O(n)$ 的时间复杂度内解决，但是多项式乘法的朴素算法是 $O(n^2)$ 的，所以我们引入了<b>快速傅里叶变换（FFT）</b>。</p><p>为了方便，下文默认相乘的两个多项式的度数均为 $n$。</p><h3 id="多项式表示法"><a href="#多项式表示法" class="headerlink" title="多项式表示法"></a>多项式表示法</h3><p>一个 $n$ 次多项式可以视作一个 $n$ 次函数的解析式，它可以用平面直角坐标系内不重复的 $n + 1$ 个点唯一表示。前者被称为<b>系数表示法</b>，后者被称为<b>点值表示法</b>。</p><script type="math/tex; mode=display">f(i)=a_0+a_1x^1+\cdots+a_nx^n\Leftrightarrow\{(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)\}\\g(i)=b_0+b_1x^1+\cdots+b_nx^n\Leftrightarrow\{(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)\}</script><p>然后就有</p><script type="math/tex; mode=display">f(x)\cdot g(x)=\sum_{i=0}^n\sum_{j=0}^na_ib_jx^{i+j}\Leftrightarrow\{(x_0, f(x_0)g(x_0)), (x_1, f(x_1)g(x_1)), \cdots, (x_n, f(x_n)g(x_n))\}</script><p>将系数表示法转化为点值表示法的过程叫做<b>离散傅里叶变换（DFT）</b>，相反的变换成为<b>离散傅里叶逆变换（IDFT）</b>。</p><h3 id="复根"><a href="#复根" class="headerlink" title="复根"></a>复根</h3><!-- ![](https://oi-wiki.org/math/poly/images/fft3.png) --><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>我们称 $x^n=1$ 的根是 $n$ 次复根，这样的根共有 $n$ 个。记 $\omega_n=e^{\frac{2\pi i}{n}}$，则 $x^n=1$ 的解集为 $\{w_n^k|k\in [0, n-1]\}$，由复平面的知识可以知道，$n$ 次单位复根是把复平面上的单位元分成 $n$ 份第一个角所对应的向量，其他的复根可以用单位复根的幂次表示。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>根据三角函数和向量的有关内容可以知道</p><script type="math/tex; mode=display">\omega_n=\cos(\frac{2\pi}{n})+i\cdot \sin(\frac{2\pi}{n})</script><p>根据定义可以得知</p><script type="math/tex; mode=display">\omega_n^n=1\\\omega_n^k=\omega_{2n}^{2k}\\\omega_n^{k+n}=-\omega_n^k</script><h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><p>快速傅里叶变换使用分治的思想进行 DFT 和 IDFT。</p><h4 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h4><p>举个例子，对于一共 $8$ 项的多项式</p><script type="math/tex; mode=display">f(x)=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7</script><p>按照奇偶将其分开</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7\\&=(a_0+a_2x^2+a_4x^4+a_6x^6)+x(a_1+a_3x^2+a_5x^4+a_7x^6)\end{aligned}</script><p>建立两个新的函数</p><script type="math/tex; mode=display">G(x)=a_0+a_2x+a_4x^2+a_6x^3\\H(x)=a_1+a_3x+a_5x^2+a_7x^3</script><p>根据单位复根的性质可以得到</p><script type="math/tex; mode=display">\begin{aligned}DFT(f(\omega_n^k))&=DFT(G(\omega_n^k)^2)+\omega_n^k\cdot DFT(H(\omega_n^k)^2)\\&=DFT(G(\omega_n^{2k}))+w_n^k\cdot DFT(H(\omega_n^{2k}))\\&=DFT(G(\omega_{\frac{n}{2}}^{k}))+w_n^k\cdot (H(\omega_{\frac{n}{2}}^{k}))\end{aligned}</script><p>同理可得</p><script type="math/tex; mode=display">DFT(f(\omega_n^k))=DFT(G(\omega_{\frac{n}{2}}^{k}))-w_n^k\cdot (H(\omega_{\frac{n}{2}}^{k}))</script><p>发现如果我们能求出 $DFT(G(x))$ 和 $DFT(H(x))$ 的话，就可以求解 $DFT(f(x))$。因此，我们可以分治求解 DFT。</p><p>注意，当我们使用分治 DFT 的时候，要使得原多项式的项数保持在 $2^m-1$ 的状态，否则会导致右边系数缺失。</p><h4 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h4><p>设原有多项式为 $f(x)=\sum_{i=0}^{n-1}a_ix^i$，我们已经知道了横坐标均为 $n$ 次复根的点值表示法，需要求 $f(x)$ 的系数表示法。</p><p>考虑使用构造法。设 $y_i=f(w_n^i)$，构造多项式如下</p><script type="math/tex; mode=display">A(x)=\sum_{i=0}^{n-1}y_ix_i</script><p>这就相当于把 $f(x)$ 点值表示法的纵坐标当作 $A(x)$ 系数表示法的系数。</p><p>设 $b_i=\omega_n^{-i}$，则 $A(x)$ 的点值表示法为 $\{(b_0, A(b_0)),(b_1, A(b_1)),\cdots,(b_{n-1}, A(b_{n-1}))\}$。</p><p>然后推一下式子</p><script type="math/tex; mode=display">\begin{aligned}A(b_k)&=\sum_{i=0}^{n-1}y_i\omega_n^{-ik}\\&=\sum_{i=0}^{n-1}\omega_n^{-ik}\sum_{j=0}^{n-1}a_j(\omega_n^i)^j\\&=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}\omega_n^{-ik}a_j(\omega_n^i)^j\\&=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}(\omega_n^{j-k})^i\end{aligned}</script><p>设 $S(\omega_n^a)$ 表示 $\sum_{i=0}^{n-1}(\omega_n^a)^i$。</p><p>当 $a=0$ 时，$S(\omega_n^a)=n$。<br>当 $a\not ={0}$ 时，</p><script type="math/tex; mode=display">\begin{aligned}S(\omega_n^a)&=\sum_{i=0}^{n-1}(\omega_n^a)^i\\(\omega_n^a)^nS(\omega_n^a)&=\sum_{i=1}^{n}(\omega_n^a)^i\\\omega_n^aS(\omega_n^a)&=\sum_{i=1}^{n}(\omega_n^a)^i\\\end{aligned}</script><p>做差可得</p><script type="math/tex; mode=display">S(\omega_n^a)=\frac{(\omega_n^a)^n-(\omega_n^a)^0}{\omega_n^a-1}=\frac{(\omega_n^n)^a-(\omega_n^a)^0}{\omega_n^a-1}=\frac{1-1}{\omega_n^a-1}=0\\</script><p>整理可得</p><script type="math/tex; mode=display">S(\omega_n^a)=\begin{cases}n&a=0\\0&a\not=0\end{cases}</script><p>所以</p><script type="math/tex; mode=display">A(b_k)=\sum_{i=0}^{n-1}a_jS(\omega_n^{j-k})=\sum_{i=0}^{n-1}a_j\cdot n</script><p>所以此时 $A$ 的点值表示法为 $\{(b_0, a_0\cdot n),(b_1, a_1\cdot n),\cdots,(b_{n-1},a_{n-1}\cdot n)\}$。再使用 FFT 对多项式 $A$ 进行一边 DFT，将其点值表示法纵坐标都除以 $n$ 即可得到 $f$ 的系数表示法。</p><h4 id="蝴蝶变换"><a href="#蝴蝶变换" class="headerlink" title="蝴蝶变换"></a>蝴蝶变换</h4><p>快速傅里叶变换的时间复杂度已经是 $O(nlogn)$，但是由于递归和动态申请空间的常数很有可能会 TLE，所以可以使用迭代替代递归，蝴蝶变换代替动态申请空间使得常数变低。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FL(a, b, c) memset(a, b, c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RE() cout &lt;&lt; <span class="hljs-string">&quot;What Happened?&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TE() cerr &lt;&lt; <span class="hljs-string">&quot;Time : &quot;</span> &lt;&lt; clock() &lt;&lt; <span class="hljs-string">&quot;(ms)&quot;</span> &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DG(x) cout &lt;&lt; <span class="hljs-string">&quot;Debug : &quot;</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &lt;= c; ++a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a &gt;= c; --a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastIN</span> &#123;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-keyword">inline</span> FastIN&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T&amp; x) &#123;<br>x = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(getchar())</span></span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch) <span class="hljs-built_in">and</span> (ch != <span class="hljs-string">&#x27;-&#x27;</span>)) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) sd = <span class="hljs-literal">true</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">true</span>) x = -x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125; IN;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">INF</span><span class="hljs-params">(~<span class="hljs-number">0u</span> &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T&amp; x_)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_); &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CL</span><span class="hljs-params">(T &amp;x_, Args&amp; ...others)</span> </span>&#123; <span class="hljs-built_in">FL</span>(x_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> x_), <span class="hljs-built_in">CL</span>(others...); &#125;<br><span class="hljs-keyword">typedef</span> complex &lt; <span class="hljs-type">double</span> &gt; Comp;<br><span class="hljs-function"><span class="hljs-type">const</span> Comp <span class="hljs-title">I</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> <span class="hljs-title">PI</span><span class="hljs-params">(acos(<span class="hljs-number">-1</span>))</span></span>;<br><br><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">kN</span><span class="hljs-params">(<span class="hljs-number">4e6</span> + <span class="hljs-number">16</span>)</span></span>;<br><span class="hljs-type">int</span> N, M, <span class="hljs-built_in">Lim</span>(<span class="hljs-number">1</span>);<br>Comp F[kN], G[kN];<br><span class="hljs-type">int</span> Rev[kN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Change</span><span class="hljs-params">(Comp y[], <span class="hljs-type">int</span> Len)</span> </span>&#123;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Len - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (i &lt; Rev[i]) <span class="hljs-built_in">swap</span>(y[i], y[Rev[i]]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Comp y[], <span class="hljs-type">int</span> Len, <span class="hljs-type">int</span> On)</span> </span>&#123;<br><span class="hljs-built_in">Change</span>(y, Len);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">h</span>(<span class="hljs-number">2</span>); h &lt;= Len; h &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-function">Comp <span class="hljs-title">times</span><span class="hljs-params">(cos(<span class="hljs-number">2</span> * PI / h), sin(On * <span class="hljs-number">2</span> * PI / h))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt; Len; j += h) &#123;<br><span class="hljs-function">Comp <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(j); k &lt; j + h / <span class="hljs-number">2</span>; k++) &#123;<br><span class="hljs-function">Comp <span class="hljs-title">u</span><span class="hljs-params">(y[k])</span>, <span class="hljs-title">t</span><span class="hljs-params">(w * y[k + h / <span class="hljs-number">2</span>])</span></span>;<br>y[k] = u + t, y[k + h / <span class="hljs-number">2</span>] = u - t;<br>w *= times;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (On == <span class="hljs-number">-1</span>) <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Len - <span class="hljs-number">1</span>) y[i] = <span class="hljs-built_in">Comp</span>(y[i].<span class="hljs-built_in">real</span>() / Len, y[i].<span class="hljs-built_in">imag</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FIO</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/In.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;I:/Code/Data/Out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IN &gt;&gt; N &gt;&gt; M; <span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, N, x) IN &gt;&gt; x, F[i] = x;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, M, x) IN &gt;&gt; x, G[i] = x;<br><span class="hljs-keyword">while</span> (Lim &lt;= N + M) Lim &lt;&lt;= <span class="hljs-number">1</span>, Log++;<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Lim <span class="hljs-number">-1</span>) Rev[i] = (Rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) &lt;&lt; (Log - <span class="hljs-number">1</span>));<br><span class="hljs-built_in">FFT</span>(F, Lim, <span class="hljs-number">1</span>), <span class="hljs-built_in">FFT</span>(G, Lim, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, Lim) F[i] *= G[i];<br><span class="hljs-built_in">FFT</span>(F, Lim, <span class="hljs-number">-1</span>);<br><span class="hljs-built_in">IR</span>(i, <span class="hljs-number">0</span>, N + M) cout &lt;&lt; (<span class="hljs-type">int</span>) (F[i].<span class="hljs-built_in">real</span>() + <span class="hljs-number">0.5</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 四舍五入防止精度误差</span><br>&#125;<br></code></pre></td></tr></table></figure><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反演浅谈</title>
    <link href="/2022/02/27/%E5%8F%8D%E6%BC%94/"/>
    <url>/2022/02/27/%E5%8F%8D%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<!-- <font size=6><center><b>反演浅谈</b></center></font> --><!-- <h1 style="border-style:none;text-align:center;">反演浅谈</h1> --><h1 id="反演浅谈"><a href="#反演浅谈" class="headerlink" title="反演浅谈"></a>反演浅谈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果有离散函数 $f$ 能推导出 离散函数 $g$，则称这个过程为“演绎”，如果我们知道了演绎的过程，想通过 $g$ 推出 $f$，这个过程通常称作“反演”。</p><p>如果两函数没有特殊性质，反演只能通过高斯消元求解，但是如果函数之间满足某种特定关系，则可以使用某些特定方式进行求解。</p><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><script type="math/tex; mode=display">g_n=\sum_{i=0}^n\binom{n}{i}f_i\iff f_n=\sum_{i=0  }^n(-1)^{n-i}\binom{n}{i}g_i</script><p>左边为演绎过程，右边为反演过程。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>先将左边带入右边，</p><script type="math/tex; mode=display">\sum_{i=0}^n(-1)^{n-i}\binom{n}{i}g_i=\sum_{i=0}^n(-1)^{n-i}\binom{n}{i}\sum_{j=0}^i\binom{n}{j}f_j</script><p>考虑交换枚举顺序（交换之前可以认为是在逐行枚举杨辉三角，交换之后可以视作按列枚举杨辉三角），</p><script type="math/tex; mode=display">\sum_{j=0}^n\sum_{i=j}^n(-1)^{n-i}\binom{n}{i}\binom{i}{j}f_j</script><p>将中间的组合数拆开来算，</p><script type="math/tex; mode=display">\binom{n}{i}\binom{i}{j}=\frac{n!}{i!(n-i)!}\cdot\frac{i!}{j!(i-j)!}=\frac{n!}{j!(n-j)!}\cdot\frac{(n-j)!}{(n-i)!(i-j)!}=\binom{n}{j}\binom{n-j}{n-i}</script><p>原式等于</p><script type="math/tex; mode=display">\sum_{j=0}^n\sum_{i=j}^n(-1)^{n-i}\binom{n}{j}\binom{n-j}{n-i}f_j</script><p>将和 $i$ 无关的提到前面，</p><script type="math/tex; mode=display">\sum_{j=0}^n\binom{n}{j}f_j\sum_{i=j}^n(-1)^{n-i}\binom{n-j}{n-i}</script><p>第二个求和符号改为枚举 $k$，使得 $i=n-k$，</p><script type="math/tex; mode=display">\sum_{j=0}^m\binom{n}{j}f_j\sum_{k=0}^{n-j}(-1)^{k}\binom{n-j}{n-k}</script><p>然后可以分情况讨论，</p><ul><li>如果 $j\not= n$，后面的和式可以使用二项式定理求出和为 $0$。</li><li>如果 $j=n$，和式为 $\binom{n}{n}f_n\cdot 1$。</li></ul><p>所以等式得证。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>看几个例子吧。</p><h4 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h4><p>起初 $n$ 个物品一一对应地放进 $n$ 个盒子里，然后打乱顺序，问任意物品都不在原来位置的方案数。</p><p>设 $f_i$ 表示有 $i$ 个物品不在原来位置的方案数， $g_i$ 表示所有的方案数。很容易得到下式</p><script type="math/tex; mode=display">g_i=\sum_{i=0}^n\binom{n}{i}f_i</script><p>根据二项式反演可以得到</p><script type="math/tex; mode=display">f_n=\sum_{i=0}^n(-1)^{n-i}\binom{n}{i}g_i</script><p>注意到 $g_n=n!$，所以</p><script type="math/tex; mode=display">f_n=\sum_{i=0}^n(-1)^{n-i}\frac{n!}{i!(n-i)!}\cdot i!</script><p>略微整理一下</p><script type="math/tex; mode=display">f_n=n!\sum_{i=0}^n\frac{(-1)^{n-i}}{(n-i)!}</script><p>改变一下 $i$ 的含义（令 $i=n-i$），</p><script type="math/tex; mode=display">f_n=n!\sum_{i=0}^n\frac{(-1)^i}{i!}</script><p>然后我们就得到了错排的通项公式！</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h3><p>定义两个数论函数的的卷积 $(f*g)(n):=\sum_{e|n}f(e)g(\frac{n}{e})$。<br>迪利克雷卷积的单位元为 $\varepsilon(n)=[n==1]$。</p><p>卷积运算主要有以下推论：</p><ul><li>$\mu * I = \varepsilon$</li><li>$\varphi * I = Id$</li><li>$\sigma * \mu=I * I * \mu = I * \varepsilon=I$，其中 $\sigma$ 表示约数个数函数。</li></ul><h3 id="反演形式"><a href="#反演形式" class="headerlink" title="反演形式"></a>反演形式</h3><p>若 $g(n)=\sum_{e|b}f(e)$，即 $g=f*I$，根据卷积的推论可以得到</p><script type="math/tex; mode=display">f*I*\mu=g*\mu\Rightarrow f=g*\mu</script><p>若 $g$ 有简洁的通项公式，加之 $\mu$ 可以使用线性筛或者杜教筛等方法，可以在 $O(n)$ 甚至 $O(n^{\frac{2}{3}})$ 的时间内求解 $f(n)$。</p><script>var a=document.getElementsByTagName("h1");for(var i=0;i<a.length;++i)if(a[i].parentNode.className.indexOf("markdown-body")>-1)document.getElementById("subtitle").title=a[i].innerHTML,a[i].parentNode.removeChild(a[i]);</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开端</title>
    <link href="/2022/02/27/%E5%BC%80%E7%AB%AF/"/>
    <url>/2022/02/27/%E5%BC%80%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>2022-02-27：__Xu128’s Blog 搭建完成！</p>]]></content>
    
    
    <categories>
      
      <category>开端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
